Code description: 

In this novel scoring function, I propose to incorporate a combination of the hop count and edge centrality measures. First, I calculate the hop count between nodes to prioritize edges that connect nodes that are closer in terms of hops. Then, I compute the edge centrality score, which considers the inverse distances based on the sum of distances to other nodes. Finally, I combine the hop count and centrality score with the normalized heuristic measures from Algorithm 2 to obtain the final heuristic measures for each edge.

```python
import numpy as np
from scipy.spatial.distance import squareform

def scoring_function(distance_matrix):
    n_nodes = distance_matrix.shape[0]

    # Compute the inverse of the distance matrix
    inverse_distance_matrix = np.where(distance_matrix != 0, 1 / distance_matrix, 0)

    # Compute the average distance of connected nodes for each node
    connected_nodes_avg_distance = np.sum(inverse_distance_matrix, axis=1) / (n_nodes - 1)

    # Compute the hop count between nodes
    hop_count = np.zeros((n_nodes, n_nodes), dtype=int)
    for hop in range(1, n_nodes):
        hop_count += (distance_matrix <= hop)

    # Compute the sum of distances to other nodes for each node
    node_scores = np.sum(inverse_distance_matrix, axis=1)

    # Repeat the node scores for each edge
    edge_scores = np.repeat(node_scores[:, np.newaxis], n_nodes, axis=1)

    # Compute the heuristic measures for each edge
    heuristics = (inverse_distance_matrix * connected_nodes_avg_distance[:, np.newaxis] * hop_count) / edge_scores

    # Calculate edge centrality score
    centrality_score = np.sum(inverse_distance_matrix, axis=1) / np.sum(inverse_distance_matrix)

    # Combine hop count and centrality score with normalized heuristic measures
    heuristics *= (hop_count + centrality_score[:, np.newaxis])
    heuristics /= np.sum(heuristics, axis=1, keepdims=True)

    return heuristics
```


