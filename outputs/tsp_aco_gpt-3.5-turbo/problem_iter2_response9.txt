Code description: The novel scoring function I am going to design is called Optimized Heuristic Scoring. It combines the nearest neighbor rule from Algorithm 1 with the edge centrality concept from Algorithm 2. The heuristic measure for each edge is determined by the product of the inverse distance to the nearest neighbor and the centrality score of the starting node. This scoring function aims to prioritize edges that are both close to the nearest neighbor and have central nodes, as they are more likely to be part of the optimal solution.

```python
import numpy as np
from scipy.spatial.distance import squareform

def scoring_function(distance_matrix: np.ndarray) -> np.ndarray:
    """
    The heuristic measures indicate how promising is each edge before actually solving this TSP instance.
    
    Parameters
    ----------
    distance_matrix : np.ndarray
        The distance matrix of shape (n_nodes, n_nodes), where diagonal elements are set to inf.
    
    Returns
    -------
    heuristics: np.ndarray
        The heuristic measures of shape (n_nodes, n_nodes) for all edges. 
    """
    n_nodes = distance_matrix.shape[0]
    heuristics = np.zeros((n_nodes, n_nodes))
    
    # Find the nearest neighbor for each node
    nearest_neighbors = np.argmin(distance_matrix, axis=1)
    
    # Compute the inverse distance matrix
    inverse_distance_matrix = np.where(distance_matrix != 0, 1 / distance_matrix, 0)
    
    # Compute the sum of distances to other nodes for each node
    node_scores = np.sum(inverse_distance_matrix, axis=1)
    
    for i in range(n_nodes):
        for j in range(n_nodes):
            if i != j:
                neighbor = nearest_neighbors[i]
                heuristics[i][j] = (1 / distance_matrix[i][neighbor]) * node_scores[i]
    
    return heuristics
```

