Code description: 

In this code, I propose a novel selecting-next-node function called "Density-based Distance Balancing". This heuristic combines the MGS distance, the distance from the current node to the destination node, and the density of unvisited nodes in the vicinity of each node to select the next node to visit. 

The algorithm calculates the MGS distance for each unvisited node, similar to Algorithm 2. It then calculates the density of unvisited nodes within a certain radius of each unvisited node. Finally, it scores each unvisited node based on the MGS distance, the inverse of the distance from the current node to the destination node, and the density of unvisited nodes. 

The node with the highest score is selected as the next node to visit.

```python
import numpy as np
from scipy.spatial.distance import cdist

def select_next_node(current_node: int, destination_node: int, unvisited_nodes: set, distance_matrix: np.ndarray) -> int:
    """
    Select the next node to visit from the unvisited nodes.
    
    Parameters
    ----------
    current_node : int
        The current node.
    destination_node : int
        The destination node to return to.
    unvisited_nodes : set
        The set of unvisited nodes.
    distance_matrix : np.ndarray
        The distance matrix of shape (n_nodes, n_nodes).
    
    Returns
    -------
    nxt_node : int
        The next node to visit.
    """
    
    # Calculate MGS distance for each unvisited node
    mgs_distance = {}
    
    for node in unvisited_nodes:
        node_distance = distance_matrix[current_node][node]
        
        weight = 1
        for neighbor in unvisited_nodes:
            if neighbor != node and neighbor in distance_matrix[node]:
                weight += 1
        
        mgs_distance[node] = node_distance / (distance_matrix[current_node][destination_node] * weight)
    
    # Calculate density of unvisited nodes
    radius = np.mean(distance_matrix) / 2  # Set the radius as half of the mean distance
    
    density = {}
    for node in unvisited_nodes:
        node_coords = np.array([[distance_matrix[current_node][node], distance_matrix[node][destination_node]]])
        unvisited_coords = np.array([[distance_matrix[current_node][unvisited_node], distance_matrix[unvisited_node][destination_node]] for unvisited_node in unvisited_nodes])
        
        dists = cdist(node_coords, unvisited_coords)
        num_nodes = np.sum(dists < radius)
        
        density[node] = num_nodes / len(unvisited_nodes)
    
    scores = {}
    for node in unvisited_nodes:
        scores[node] = mgs_distance[node] * (1 / distance_matrix[current_node][node]) * density[node]
    
    nxt_node = max(scores, key=scores.get)

    return nxt_node
```
