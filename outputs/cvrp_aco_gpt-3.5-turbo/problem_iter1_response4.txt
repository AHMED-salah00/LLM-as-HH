Code description: The crossover algorithm combines the key elements of both Algorithm 1 and Algorithm 2 to create a more effective scoring function. It calculates the heuristic measure for each edge based on both the distance between nodes and their demands. The heuristic score is calculated as the product of the inverse of the distance and the demand ratio. Additionally, edges with demand exceeding the vehicle capacity are assigned a score of zero.

```python
import numpy as np

def scoring_function(distance_matrix: np.ndarray, demands: np.ndarray, CAPACITY: int) -> np.ndarray:
    n_nodes = distance_matrix.shape[0]
    
    max_distance = np.max(distance_matrix)
    max_demand = np.max(demands[1:])
    
    heuristics = np.zeros((n_nodes, n_nodes))
    
    for i in range(1, n_nodes):
        for j in range(i+1, n_nodes):
            distance = distance_matrix[i, j]
            demand_ratio = demands[j] / CAPACITY
            
            if demand_ratio > 1:
                heuristics[i, j] = 0
            else:
                inverted_distance = 1 / distance
                normalized_demand_ratio = demand_ratio / max_demand
                
                heuristics[i, j] = inverted_distance * normalized_demand_ratio
            
            # Symmetrically set heuristics for the lower triangle of the matrix
            heuristics[j, i] = heuristics[i, j]
    
    return heuristics
```

The crossover code combines the distance calculation from Algorithm 1 with the demand ratio calculation from Algorithm 2. It then follows the same logic as Algorithm 2 to check if the demand exceeds the vehicle capacity and assigns a score of zero. If the demand is below the capacity, it calculates the heuristic score as the product of the inverse of the distance and the normalized demand ratio. Finally, it symmetrically sets the heuristics for the lower triangle of the matrix to ensure consistency.
