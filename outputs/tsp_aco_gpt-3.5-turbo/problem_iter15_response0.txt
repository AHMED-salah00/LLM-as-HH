Code description: 

In this improved scoring function, I will integrate the ideas from Algorithm 1 and Algorithm 2 to create a more effective heuristic measure. The scoring function will calculate the distance information, edge importance, and node connections to determine the heuristic measures for each edge. The distance information will be taken into account through the inverse distance matrix, similar to Algorithm 2. To incorporate edge importance, I will calculate the edge importance measure by taking the average of the node degrees of the source and destination nodes. This measure captures the relative importance of the edges in the graph. Finally, I will consider the node connections as a penalty factor by multiplying the inverse distance by the inverse sum of the node connections for the source and destination nodes. This will give higher heuristic measures to edges with shorter distances and lower node connections.

```python
import numpy as np

def scoring_function(distance_matrix: np.ndarray) -> np.ndarray:
    """
    The heuristic measures indicate how promising is each edge before actually solving this TSP instance.
    
    Parameters
    ----------
    distance_matrix : np.ndarray
        The distance matrix of shape (n_nodes, n_nodes), where diagonal elements are set to inf.
    
    Returns
    -------
    heuristics: np.ndarray
        The heuristic measures of shape (n_nodes, n_nodes) for all edges. 
    """
    n_nodes = distance_matrix.shape[0]
    
    # Initialize the heuristic measures matrix
    heuristics = np.zeros((n_nodes, n_nodes))
    
    # Calculate the inverse distances
    inverse_distances = 1 / distance_matrix
    np.fill_diagonal(inverse_distances, 0)
    
    # Compute the node connections
    node_connections = np.sum(distance_matrix != np.inf, axis=1)
    
    # Compute the node degrees
    node_degrees = np.sum(distance_matrix != np.inf, axis=1) - 1
    
    # Calculate the edge importance measure
    edge_importance = (node_degrees[:, np.newaxis] + node_degrees) / (2 * np.max(node_degrees))
    
    # Calculate the heuristic measure for each edge
    for i in range(n_nodes):
        for j in range(n_nodes):
            if i != j:
                penalty_factor = inverse_distances[i, j] / (inverse_distances[i, j] * (1 + node_connections[i] + node_connections[j]))
                heuristics[i, j] = inverse_distances[i, j] * edge_importance[i, j] * penalty_factor
    
    # Normalize the heuristic measures so that they sum up to 1
    heuristics /= np.sum(heuristics)
    
    return heuristics
```

