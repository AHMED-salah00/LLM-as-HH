Code description: The proposed modified algorithm aims to incorporate additional factors in calculating the heuristic measure for each edge. In addition to demand and distance, it also considers the capacity constraint of the vehicle. The goal is to prioritize edges that have high demand, low distance, and are within the vehicle capacity.

The modified algorithm initializes an empty array for the heuristic measures. It then iterates over all pairs of nodes (i, j) and calculates the heuristic measure for the edge connecting these nodes. For each edge, the heuristic measure is calculated as follows:

- If the edge connects the depot (node 0) to a customer node (i > 0), the heuristic measure is set to the ratio of the normalized demand of the customer node to the distance. This represents the demand-density of the edge.

- If the edge connects two customer nodes (i > 0 and j > 0), the heuristic measure is set to the ratio of the normalized sum of the demands of the two nodes to the distance. This represents the demand-density of the edge.

Additionally, the modified algorithm introduces a capacity penalty factor for edges that exceed the vehicle capacity. If the demand sum of the two nodes exceeds the vehicle capacity, the heuristic measure is multiplied by a penalty factor to reduce its importance.

The resulting heuristic measures are returned as an array.

```python
import numpy as np

def scoring_function(distance_matrix: np.ndarray, demands: np.ndarray, CAPACITY: int) -> np.ndarray:
    n_nodes = distance_matrix.shape[0]
    
    max_distance = np.max(distance_matrix)
    max_demand = np.max(demands[1:])
    
    heuristics = np.zeros((n_nodes, n_nodes))
    
    for i in range(n_nodes):
        for j in range(n_nodes):
            if i != j:
                demand_sum = demands[i] + demands[j]
                distance = distance_matrix[i, j]
                
                if i == 0:
                    normalized_demand = demands[j] / max_demand
                    heuristics[i, j] = normalized_demand / distance
                elif j == 0:
                    normalized_demand = demands[i] / max_demand
                    heuristics[i, j] = normalized_demand / distance
                else:
                    normalized_demand_sum = demand_sum / max_demand
                    heuristics[i, j] = normalized_demand_sum / distance
                    
                    if demand_sum > CAPACITY:
                        heuristics[i, j] *= CAPACITY / demand_sum
    
    return heuristics
```

