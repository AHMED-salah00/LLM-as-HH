Code description: The goal of this modified scoring function is to consider both the distance and demand of each edge in a balanced manner, while also taking into account the capacity constraint. The weights for distance and demand are determined based on the maximum distance and demand values in the problem instance, and the capacity constraint is incorporated by penalizing edges with demand that exceeds the remaining capacity.

The modified scoring function initializes an empty array for the heuristic measures and calculates the maximum demand, maximum distance, and remaining capacity. It then iterates over all pairs of nodes (i, j) and calculates the heuristic measure for the edge connecting these nodes. For each edge, the heuristic measure is calculated as follows:
- If the edge connects the depot (node 0) to a customer node (i > 0), the heuristic measure is set to the sum of the weight of distance multiplied by the distance between the two nodes and the weight of demand multiplied by the demand of the customer node. If the demand of the customer node exceeds the remaining capacity, an additional penalty term is added to the heuristic measure.
- If the edge connects two customer nodes (i > 0 and j > 0), the heuristic measure is set to the sum of the weight of distance multiplied by the distance between the two nodes and the weight of demand multiplied by the sum of the demands of the two nodes. If the sum of the demands exceeds the remaining capacity, an additional penalty term is added to the heuristic measure.

The resulting heuristic measures are returned as an array.

```python
import numpy as np

def scoring_function(distance_matrix: np.ndarray, demands: np.ndarray, CAPACITY: int) -> np.ndarray:
    n_nodes = distance_matrix.shape[0]
    
    # Initialize heuristics matrix
    heuristics = np.zeros((n_nodes, n_nodes))
    
    # Calculate maximal demand, distance and remaining capacity values
    max_demand = np.max(demands[1:])
    max_distance = np.max(distance_matrix)
    remaining_capacity = CAPACITY - demands[0]
    
    # Set weight of demand and distance based on maximal values
    demand_weight = max_demand / (max_demand + max_distance)
    distance_weight = 1 - demand_weight
    
    # Calculate heuristic measures for each edge
    for i in range(n_nodes):
        for j in range(i+1, n_nodes):
            distance = distance_matrix[i, j]
            demand_sum = demands[i] + demands[j]
            
            # Calculate heuristic measure
            if i == 0:
                heuristic_measure = distance_weight * distance + demand_weight * demands[j]
                if demands[j] > remaining_capacity:
                    penalty = demands[j] - remaining_capacity
                    heuristic_measure += penalty
            else:
                heuristic_measure = distance_weight * distance + demand_weight * demand_sum
                if demand_sum > remaining_capacity:
                    penalty = demand_sum - remaining_capacity
                    heuristic_measure += penalty
            
            heuristics[i, j] = heuristic_measure
    
    # Symmetrically set heuristics for the lower triangle of the matrix
    heuristics += np.tril(heuristics.T, -1)
    
    return heuristics
```
