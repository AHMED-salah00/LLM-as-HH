Code description: The improved crossover algorithm combines the strengths of Algorithm 1 and Algorithm 2 to create a more effective scoring function. It considers distance, demand, and position, and incorporates vehicle capacity constraints to prioritize edges. The algorithm calculates normalized distance, demand, and position values and assigns weights to each factor to determine the final heuristic measure for each edge.

```python
import numpy as np

def scoring_function(distance_matrix: np.ndarray, demands: np.ndarray, CAPACITY: int) -> np.ndarray:
    n_nodes = distance_matrix.shape[0]

    # Initialize heuristics matrix
    heuristics = np.zeros((n_nodes, n_nodes))

    # Maximum values for normalization
    max_distance = np.max(distance_matrix)
    max_demand = np.max(demands[1:])

    # Weight parameters for distance, demand, position, and capacity constraint
    distance_weight = 0.5
    demand_weight = 0.3
    position_weight = 0.1

    for i in range(1, n_nodes):
        for j in range(i + 1, n_nodes):
            distance = distance_matrix[i, j]
            demand = demands[j]

            # Calculate normalized distance, demand, and position
            normalized_distance = distance / max_distance
            normalized_demand = demand / max_demand
            normalized_position = (j - 1) / (n_nodes - 1)

            # Check capacity constraint
            if demand > CAPACITY:
                heuristics[i, j] = 0
            else:
                # Calculate heuristics measure
                heuristics[i, j] = (
                    distance_weight * normalized_distance +
                    demand_weight * normalized_demand +
                    position_weight * normalized_position
                )
            heuristics[j, i] = heuristics[i, j]

    return heuristics
```

