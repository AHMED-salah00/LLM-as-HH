Code description:
In this improved scoring function, I will combine the strategies used in Algorithm 1 and Algorithm 2. First, I will compute the inverse of the distance matrix, similar to Algorithm 1. Then, I will normalize these inverse distances to create a measure of the importance of each node, similar to Algorithm 1. Finally, I will use these normalized inverse distances to calculate the heuristic measures for each edge, similar to Algorithm 2.

```python
import numpy as np

def scoring_function(distance_matrix: np.ndarray) -> np.ndarray:
    """
    The heuristic measures indicate how promising is each edge before actually solving this TSP instance.

    Parameters
    ----------
    distance_matrix : np.ndarray
        The distance matrix of shape (n_nodes, n_nodes), where diagonal elements are set to inf.

    Returns
    -------
    heuristics: np.ndarray
        The heuristic measures of shape (n_nodes, n_nodes) for all edges.
    """
    n_nodes = distance_matrix.shape[0]

    # Compute the inverse of the distance matrix
    inverse_distance_matrix = np.where(distance_matrix != 0, 1 / distance_matrix, 0)

    # Normalize the inverse distances to create node importance measures
    node_scores = inverse_distance_matrix / np.sum(inverse_distance_matrix)

    # Repeat the node scores for each edge
    edge_scores = np.repeat(node_scores[:, np.newaxis], n_nodes, axis=1)

    # Compute the heuristic measures for each edge
    heuristics = inverse_distance_matrix / edge_scores

    return heuristics
```

