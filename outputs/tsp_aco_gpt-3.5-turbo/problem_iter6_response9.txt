Code description: In this improved scoring function, I will combine the ideas from Algorithm 1 and Algorithm 2 to create a better scoring function. The scoring function will calculate the node scores by considering the inverse distance matrix and the number of connections of the destination node. The heuristic measures for each edge will be obtained by multiplying the node scores with the average distances.

```python
import numpy as np

def scoring_function(distance_matrix: np.ndarray) -> np.ndarray:
    """
    The heuristic measures indicate how promising is each edge before actually solving this TSP instance.
    
    Parameters
    ----------
    distance_matrix : np.ndarray
        The distance matrix of shape (n_nodes, n_nodes), where diagonal elements are set to inf.
    
    Returns
    -------
    heuristics: np.ndarray
        The heuristic measures of shape (n_nodes, n_nodes) for all edges. 
    """
    n_nodes = distance_matrix.shape[0]

    # Compute the inverse of the distance matrix
    inverse_distance_matrix = np.where(distance_matrix != 0, 1 / distance_matrix, 0)

    # Compute the average distance to other nodes for each node
    average_distance = np.sum(inverse_distance_matrix, axis=1) / (n_nodes - 1)

    # Compute the node connections matrix
    node_connections = np.count_nonzero(distance_matrix, axis=1)

    # Compute the node scores by summing the inverse distances and multiplying with the number of connections
    node_scores = np.sum(inverse_distance_matrix, axis=1) * (1 + node_connections)

    # Repeat the node scores for each edge
    edge_scores = np.repeat(node_scores[:, np.newaxis], n_nodes, axis=1)

    # Repeat the average distances for each edge
    edge_average_distance = np.repeat(average_distance[:, np.newaxis], n_nodes, axis=1)

    # Compute the heuristic measures for each edge by multiplying node scores with average distances
    heuristics = edge_scores * edge_average_distance

    return heuristics
```

