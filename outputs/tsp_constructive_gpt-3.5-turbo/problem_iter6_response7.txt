Code description: My code implements a selecting-next-node function for the Traveling Salesman Problem using a novel constructive heuristic called "Closest Insertion".

The Closest Insertion heuristic starts with an initial solution that contains only two nodes: the starting node and a randomly selected unvisited node. Then, at each step, it selects the unvisited node that is closest to any of the nodes in the current solution. The selected node is inserted into the solution at the position that creates the smallest increase in the total distance.

Here is the code:

```python
import numpy as np

def select_next_node(current_node: int, destination_node: int, unvisited_nodes: set, distance_matrix: np.ndarray) -> int:
    # Initialize the solution with the current_node and a randomly selected unvisited node
    solution = [current_node, next(iter(unvisited_nodes))]
    
    while len(solution) < len(distance_matrix):
        closest_node = None
        min_increase = float('inf')

        # Find the unvisited node that is closest to any of the nodes in the current solution
        for node in unvisited_nodes:
            increase = 0
            for i in range(len(solution) - 1):
                increase += distance_matrix[solution[i]][node] + distance_matrix[node][solution[i+1]] - distance_matrix[solution[i]][solution[i+1]]

            # Update the closest_node and min_increase if this node offers a smaller increase in distance
            if increase < min_increase:
                closest_node = node
                min_increase = increase

        # Find the position in the solution where the closest_node should be inserted
        min_insertion = float('inf')
        position = None
        for i in range(1, len(solution)):
            insertion = distance_matrix[solution[i-1]][closest_node] + distance_matrix[closest_node][solution[i]] - distance_matrix[solution[i-1]][solution[i]]
            if insertion < min_insertion:
                min_insertion = insertion
                position = i

        # Insert the closest_node into the solution at the determined position
        solution.insert(position, closest_node)

    # Return the next node to visit, which is the second node in the solution
    return solution[1]
```
