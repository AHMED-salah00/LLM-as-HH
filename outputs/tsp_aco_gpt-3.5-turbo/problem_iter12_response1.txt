Code description: 

The modified scoring function aims to improve upon the original by incorporating additional information from the distance matrix. The function calculates the inverse distances, similar to Algorithm 2, and then applies a modification factor based on the number of connections for each node. The modification factor is calculated as the ratio of the inverse distance between two nodes and the number of connections for the destination node. The modified heuristics are then normalized.

```python
import numpy as np


def scoring_function(distance_matrix: np.ndarray) -> np.ndarray:
    """
    The heuristic measures indicate how promising is each edge before actually solving this TSP instance.

    Parameters
    ----------
    distance_matrix : np.ndarray
        The distance matrix of shape (n_nodes, n_nodes), where diagonal elements are set to inf.

    Returns
    -------
    heuristics: np.ndarray
        The heuristic measures of shape (n_nodes, n_nodes) for all edges.
    """

    n_nodes = distance_matrix.shape[0]

    # Calculate the inverse distances
    inverse_distances = 1 / distance_matrix
    np.fill_diagonal(inverse_distances, 0)

    # Compute the number of connections for each node
    node_degrees = np.count_nonzero(distance_matrix, axis=1)

    # Initialize the heuristic measures matrix
    heuristics = np.zeros((n_nodes, n_nodes))

    # Calculate the heuristic measure for each edge
    for i in range(n_nodes):
        for j in range(n_nodes):
            if i != j:
                mod_factor = inverse_distances[i, j] / (1 + node_degrees[j])
                heuristics[i, j] = inverse_distances[i, j] * mod_factor

    # Normalize the heuristic measures so that they sum up to 1
    heuristics /= np.sum(heuristics)

    return heuristics
```
