Code description: In this crossover algorithm, I will combine the concepts from Algorithm 1 and Algorithm 2 to create a novel scoring function. The new scoring function will incorporate the ideas of hop count, average distance of connected nodes, edge centrality, and normalized heuristic measures. By considering these factors, the scoring function aims to provide more accurate and effective heuristic measures for each edge. Additionally, I will modify the computation of the hop count to include only the direct neighbors of a node, instead of considering all nodes within a certain hop range.

```python
import numpy as np

def scoring_function(distance_matrix: np.ndarray) -> np.ndarray:
    """
    The heuristic measures indicate how promising is each edge before actually solving this TSP instance.
    
    Parameters
    ----------
    distance_matrix : np.ndarray
        The distance matrix of shape (n_nodes, n_nodes), where diagonal elements are set to inf.
    
    Returns
    -------
    heuristics: np.ndarray
        The heuristic measures of shape (n_nodes, n_nodes) for all edges. 
    """
    n_nodes = distance_matrix.shape[0]
    
    # Compute the inverse of the distance matrix
    inverse_distance_matrix = np.where(distance_matrix != 0, 1 / distance_matrix, 0)
    
    # Compute the average distance of connected nodes for each node
    connected_nodes_avg_distance = np.sum(inverse_distance_matrix, axis=1) / (n_nodes - 1)
    
    # Compute the hop count between nodes
    hop_count = np.where(distance_matrix <= 1, 1, 0)
    
    # Compute the sum of distances to other nodes for each node
    node_scores = np.sum(inverse_distance_matrix, axis=1)
    
    # Compute the edge centrality score
    centrality_score = np.sum(inverse_distance_matrix, axis=1) / np.sum(inverse_distance_matrix)
    
    # Compute the heuristic measures for each edge
    heuristics = (inverse_distance_matrix * connected_nodes_avg_distance[:, np.newaxis] * hop_count) * centrality_score[:, np.newaxis]
    
    # Normalize the heuristic measures so that they sum up to 1
    heuristics /= np.sum(heuristics, axis=1, keepdims=True)
    
    return heuristics
```

