Code description: This code modification aims to enhance the selection of the next node to visit by considering both uncertainty and distance, while also adding an element of randomness to explore different paths. The modified code calculates the weight for each unvisited node by combining the uncertainty score and the inverse of the distance. In addition to selecting the node with the highest weight, the modified code introduces a random element by selecting a random node from the top weighted nodes, instead of always selecting the first node.

```python
import numpy as np

def select_next_node(current_node: int, destination_node: int, unvisited_nodes: set, distance_matrix: np.ndarray) -> int:
    """
    Select the next node to visit from the unvisited nodes based on uncertainty and distance.
    
    Parameters
    ----------
    current_node : int
        The current node.
    destination_node : int
        The destination node to return to.
    unvisited_nodes : set
        The set of unvisited nodes.
    distance_matrix : np.ndarray
        The distance matrix of shape (n_nodes, n_nodes).
    
    Returns
    -------
    nxt_node : int
        The next node to visit.
    """
    distances = distance_matrix[current_node]
    uncertainty_scores = []
    weights = []
    nxt_node = -1

    for node in unvisited_nodes:
        distance = distances[node]
        variability = np.std(distance_matrix[:, node])
        
        uncertainty_scores.append(variability)
        weights.append(variability / distance)
    
    max_weight = np.max(weights)
    top_weight_nodes = [node for node, weight in zip(unvisited_nodes, weights) if weight == max_weight]
    nxt_node = np.random.choice(top_weight_nodes)

    return nxt_node
```


