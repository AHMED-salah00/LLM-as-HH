Code description: In this improved scoring function, I will combine the concepts used in Algorithm 1 and Algorithm 2 to assign heuristic measures to each edge. First, I will compute the inverse distances of each edge similar to Algorithm 2. Then, I will calculate the node degrees, similar to Algorithm 1. Finally, I will combine these measures to compute the heuristic measures for each edge. Additionally, I will normalize the heuristic measures so that they sum up to 1 to ensure that the heuristics can be interpreted as probabilities.

```python
import numpy as np


def scoring_function(distance_matrix: np.ndarray) -> np.ndarray:
    """
    The heuristic measures indicate how promising is each edge before actually solving this TSP instance.

    Parameters
    ----------
    distance_matrix : np.ndarray
        The distance matrix of shape (n_nodes, n_nodes), where diagonal elements are set to inf.

    Returns
    -------
    heuristics: np.ndarray
        The heuristic measures of shape (n_nodes, n_nodes) for all edges.
    """

    n_nodes = distance_matrix.shape[0]

    # Compute the inverse distances
    inverse_distances = 1 / distance_matrix
    np.fill_diagonal(inverse_distances, 0)

    # Compute the node degrees
    node_degrees = np.sum(distance_matrix != np.inf, axis=1)

    # Calculate the heuristic measures
    heuristics = np.zeros((n_nodes, n_nodes))
    for i in range(n_nodes):
        for j in range(n_nodes):
            if i != j:
                heuristics[i, j] = inverse_distances[i, j] * ((inverse_distances[i, j] / (1 + node_degrees[j])) ** 2)

    # Normalize the heuristic measures so that they sum up to 1
    heuristics /= np.sum(heuristics)

    return heuristics
```
