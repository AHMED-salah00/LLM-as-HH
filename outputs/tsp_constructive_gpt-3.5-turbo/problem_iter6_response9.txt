-----
Code description: The improved code selects the next node to visit based on a combination of uncertainty and distance, while also considering the importance of both factors. It calculates the weight for each unvisited node by combining the uncertainty score and the inverse of the distance. The next node is then selected by choosing the node with the highest weight. 

This code introduces a novel element by assigning different weights to the uncertainty score and the distance, allowing for a more balanced selection process. Additionally, it adds a level of randomness by selecting a random node from the top-weighted nodes, rather than always selecting the node with the highest weight.

```python
import numpy as np

def select_next_node(current_node: int, destination_node: int, unvisited_nodes: set, distance_matrix: np.ndarray) -> int:
    """
    Select the next node to visit from the unvisited nodes based on a combination of uncertainty and distance, while introducing randomness.
    
    Parameters
    ----------
    current_node : int
        The current node.
    destination_node : int
        The destination node to return to.
    unvisited_nodes : set
        The set of unvisited nodes.
    distance_matrix : np.ndarray
        The distance matrix of shape (n_nodes, n_nodes).
    
    Returns
    -------
    nxt_node : int
        The next node to visit.
    """
    distances = distance_matrix[current_node]
    uncertainty_scores = []
    weights = []
    nxt_node = -1

    for node in unvisited_nodes:
        distance = distances[node]
        variability = np.std(distance_matrix[:, node])
        
        uncertainty_scores.append(variability)
        weights.append(variability / distance)  # Calculate the weight for each unvisited node

    max_weight = np.max(weights)
    top_weight_nodes = [node for node, weight in zip(unvisited_nodes, weights) if weight == max_weight]
    nxt_node = np.random.choice(top_weight_nodes)  # Select a random node with the highest weight

    return nxt_node
```
-----
