Code description:
In this improved scoring function, I propose to incorporate the node degree, inverse distance, and number of connections into the computation of the heuristic measures. The idea is to consider both the distance and the number of connections of the destination node, as well as the node degree, to prioritize edges that have a close destination node with fewer connections. Additionally, the heuristic measures will be normalized to have a value between 0 and 1.

```python
import numpy as np

def scoring_function(distance_matrix: np.ndarray) -> np.ndarray:
    """
    The heuristic measures indicate how promising is each edge before actually solving this TSP instance.
    
    Parameters
    ----------
    distance_matrix : np.ndarray
        The distance matrix of shape (n_nodes, n_nodes), where diagonal elements are set to inf.
    
    Returns
    -------
    heuristics: np.ndarray
        The heuristic measures of shape (n_nodes, n_nodes) for all edges. 
    """
    n_nodes = distance_matrix.shape[0]
    
    # Initialize the node connections matrix
    node_connections = np.zeros(n_nodes, dtype=int)
    
    # Count the number of connections for each node
    for i in range(n_nodes):
        node_connections[i] = np.count_nonzero(distance_matrix[i])
    
    # Calculate the inverse distances
    inverse_distances = 1 / distance_matrix
    np.fill_diagonal(inverse_distances, 0)
    
    # Calculate node degree
    node_degree = np.sum(distance_matrix != np.inf, axis=1)
    
    # Repeat the node degree for each edge
    edge_degree = np.repeat(node_degree[:, np.newaxis], n_nodes, axis=1)
    
    # Compute the heuristic measures for each edge by combining inverse distance, node degree, and number of connections
    heuristics = inverse_distances * (1 / (distance_matrix * (1 + node_degree) * (1 + node_connections)))
    
    # Normalize the heuristic measures to have values between 0 and 1
    heuristics = heuristics / np.max(heuristics)
    
    return heuristics
```
