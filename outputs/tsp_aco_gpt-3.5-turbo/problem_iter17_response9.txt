Code description: The crossover algorithm incorporates elements from both Algorithm 1 and Algorithm 2 to create a novel scoring function. It considers the distance between nodes, the degree centrality of nodes, the edge importance measure, and the closeness centrality of nodes.

The modified scoring function includes the following steps:
1. Compute the inverse of the distance matrix.
2. Compute the degree centrality of each node.
3. Compute the number of connections for each node.
4. Create a graph from the distance matrix.
5. Compute the clustering coefficient of each node.
6. Compute the edge importance measure based on the degree centrality and the distance between nodes.
7. Compute the closeness centrality of each node.
8. Calculate the heuristic measures by combining the inverse distance matrix, degree centrality, edge importance, and closeness centrality.
9. Normalize the heuristic measures so that they sum up to 1.

```python
import numpy as np
import networkx as nx
from scipy.sparse import csgraph

def scoring_function(distance_matrix: np.ndarray) -> np.ndarray:
    """
    The heuristic measures indicate how promising is each edge before actually solving this TSP instance.
    
    Parameters
    ----------
    distance_matrix : np.ndarray
        The distance matrix of shape (n_nodes, n_nodes), where diagonal elements are set to inf.
    
    Returns
    -------
    heuristics: np.ndarray
        The heuristic measures of shape (n_nodes, n_nodes) for all edges. 
    """
    n_nodes = distance_matrix.shape[0]
   
    # Compute the inverse of the distance matrix
    inverse_distance_matrix = np.where(distance_matrix != 0, 1 / distance_matrix, 0)
    
    # Compute the degree centrality of each node
    degree_centrality = np.sum(inverse_distance_matrix, axis=1) / (n_nodes - 1)
    
    # Compute the number of connections for each node
    node_degrees = np.count_nonzero(distance_matrix, axis=1) - 1  # Subtract 1 to exclude self-loop
    
    # Create a graph from the distance matrix
    graph = nx.from_numpy_array(distance_matrix)
    
    # Compute the clustering coefficient of each node
    clustering_coefficient = np.array([nx.clustering(graph, node) for node in range(n_nodes)])
    
    # Compute the edge importance measure
    edge_importance = np.zeros((n_nodes, n_nodes))
    max_node_score = np.max(node_degrees)
    for i in range(n_nodes):
        for j in range(n_nodes):
            distance_score = 1 / (distance_matrix[i,j] + 1)
            edge_importance[i, j] = (node_degrees[i] + node_degrees[j]) / (2 * max_node_score) * distance_score
    
     # Compute the closeness centrality of each node
    closeness_centrality = csgraph.shortest_path(distance_matrix, directed=False)
    closeness_centrality = 1 / np.average(closeness_centrality, axis=1)
    
    # Calculate the heuristic measures
    heuristics = inverse_distance_matrix * degree_centrality[:, np.newaxis] * edge_importance * closeness_centrality
    
    # Normalize the heuristic measures so that they sum up to 1
    heuristics /= np.sum(heuristics)
    
    return heuristics
```
