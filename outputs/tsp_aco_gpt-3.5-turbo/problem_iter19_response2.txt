Code description: In this improved scoring function, I will combine elements from both Algorithm 1 and Algorithm 2. The function will calculate the inverse distances of each edge, similar to Algorithm 2. Additionally, I will consider the degree centrality of the destination node, similar to Algorithm 1. I will calculate the degree centrality of each node using the inverse distances matrix and then incorporate it into the heuristic measures by multiplying the inverse distance with the degree centrality of the destination node. This way, I can take into account both the distance and the centrality measure of the destination node, prioritizing edges that connect to central nodes.

```python
import numpy as np

def scoring_function(distance_matrix: np.ndarray) -> np.ndarray:
    """
    The heuristic measures indicate how promising is each edge before actually solving this TSP instance.
    
    Parameters
    ----------
    distance_matrix : np.ndarray
        The distance matrix of shape (n_nodes, n_nodes), where diagonal elements are set to inf.
    
    Returns
    -------
    heuristics: np.ndarray
        The heuristic measures of shape (n_nodes, n_nodes) for all edges. 
    """
    n_nodes = distance_matrix.shape[0]
    
    # Calculate the inverse distances
    inverse_distances = 1 / distance_matrix
    np.fill_diagonal(inverse_distances, 0)
    
    # Calculate the degree centrality of each node
    degree_centrality = np.sum(inverse_distances, axis=1) / (n_nodes - 1)
    
    # Initialize the heuristic measures matrix
    heuristics = np.zeros((n_nodes, n_nodes))
    
    # Calculate the heuristic measure for each edge
    for i in range(n_nodes):
        for j in range(n_nodes):
            if i != j:
                heuristics[i, j] = inverse_distances[i, j] * degree_centrality[j]
    
    # Normalize the heuristic measures so that they sum up to 1
    heuristics /= np.sum(heuristics)
    
    return heuristics
```

