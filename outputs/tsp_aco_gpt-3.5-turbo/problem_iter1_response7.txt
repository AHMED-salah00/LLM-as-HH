Code description: In this code, I will combine the approaches from Algorithm 1 and Algorithm 2 to create a novel scoring function. The scoring function will first calculate the inverse distances of each edge, similar to Algorithm 2. Then, it will generate random permutations of the nodes and calculate the cost of each permutation using the provided distance_matrix, similar to Algorithm 1. The heuristic measures will be obtained by multiplying the inverse distances with the inverse of the cost of each permutation.

```python
import numpy as np

def scoring_function(distance_matrix: np.ndarray) -> np.ndarray:
    """
    The heuristic measures indicate how promising is each edge before actually solving this TSP instance.
    
    Parameters
    ----------
    distance_matrix : np.ndarray
        The distance matrix of shape (n_nodes, n_nodes), where diagonal elements are set to inf.
    
    Returns
    -------
    heuristics: np.ndarray
        The heuristic measures of shape (n_nodes, n_nodes) for all edges. 
    """
    n_nodes = distance_matrix.shape[0]
    heuristics = np.zeros((n_nodes, n_nodes))

    # Calculate the inverse distances
    inverse_distances = 1 / distance_matrix
    np.fill_diagonal(inverse_distances, 0)
    total_sum = np.sum(inverse_distances)

    for i in range(n_nodes):
        for j in range(n_nodes):
            if i != j:
                permutations = np.random.permutation(n_nodes)
                cost = np.sum(distance_matrix[permutations[:-1], permutations[1:]])
                heuristic = inverse_distances[i, j] * (1 / cost)
                heuristics[i, j] = heuristic
    
    return heuristics
```

