Code description: The proposed novel selecting-next-node function is called "Mixed Scoring". This algorithm combines the ideas from both Algorithm 1 and Algorithm 2 to select the next node that balances distance and attractiveness.

1. Calculate the distances from the current node to all unvisited nodes and the distances from the destination node to all unvisited nodes, similar to Algorithm 2.
2. Calculate the weighted distances, which is the sum of the distances from the current node to all unvisited nodes and the distances from the destination node to those unvisited nodes, just like Algorithm 2.
3. Calculate the attractiveness of each unvisited node based on the dynamically adjusted alpha value and the pheromone levels, similar to Algorithm 2.
4. Calculate the weights for each unvisited node based on the weighted distances and the attractiveness. The weights are determined by combining the two scores using a user-defined parameter `beta`.
5. Select the unvisited node with the maximum weight as the next node to visit and return it as the output of the function.

```python
import numpy as np

def select_next_node(current_node: int, destination_node: int, unvisited_nodes: set, distance_matrix: np.ndarray, alpha: float, beta: float) -> int:
    """
    Select the next node to visit from the unvisited nodes.
    
    Parameters
    ----------
    current_node : int
        The current node.
    destination_node : int
        The destination node to return to.
    unvisited_nodes : set
        The set of unvisited nodes.
    distance_matrix : np.ndarray
        The distance matrix of shape (n_nodes, n_nodes).
    alpha : float
        The parameter alpha to adjust the exploration-exploitation trade-off.
    beta : float
        The parameter beta to adjust the balance of distance and attractiveness.
    
    Returns
    -------
    nxt_node : int
        The next node to visit.
    """
    
    # Calculate the distances from the current node to all unvisited nodes
    distances = distance_matrix[current_node, list(unvisited_nodes)]
    
    # Calculate the distances from the destination node to all unvisited nodes
    dest_distances = distance_matrix[destination_node, list(unvisited_nodes)]
    
    # Calculate the weighted distances, which is the sum of the distances from the current node to all unvisited nodes and the distances from the destination node to those unvisited nodes
    weighted_distances = distances + dest_distances
    
    # Calculate attractiveness of each unvisited node based on the dynamically adjusted alpha value and the pheromone levels
    pheromone_matrix = np.full_like(distance_matrix, 0.01)  # Initialize pheromone matrix with small values
    attractiveness = np.exp(-alpha * pheromone_matrix[current_node, list(unvisited_nodes)])

    # Calculate the weights for each unvisited node based on the weighted distances and the attractiveness
    weights = attractiveness / weighted_distances**beta
    
    # Find the index of the unvisited node with the maximum weight
    max_index = np.argmax(weights)
    
    # Get the corresponding unvisited node
    nxt_node = list(unvisited_nodes)[max_index]
    
    return nxt_node
```
