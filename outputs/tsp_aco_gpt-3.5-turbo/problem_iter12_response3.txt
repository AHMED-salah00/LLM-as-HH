Code description: In this improved scoring function, I will combine the ideas from Algorithm 1 and Algorithm 2 to create a better scoring function. The scoring function will first calculate the inverse distances of each edge, similar to Algorithm 2. Then, instead of generating random permutations of nodes, I will use the heuristic measures calculated in Algorithm 1. The heuristic measures will now be obtained by multiplying the inverse distances with the heuristic measure of the destination node - the product of the inverse distance and the inverse number of connections. This way, I can take into account both the distance and the number of connections of the destination node, prioritizing edges that have a close destination node with fewer connections.

```python
import numpy as np

def scoring_function(distance_matrix: np.ndarray) -> np.ndarray:
    n_nodes = distance_matrix.shape[0]
    
    # Initialize the node connections matrix
    node_connections = np.zeros(n_nodes, dtype=int)
    
    # Count the number of connections for each node
    for i in range(n_nodes):
        node_connections[i] = np.count_nonzero(distance_matrix[i])
    
    # Calculate the inverse distances
    inverse_distances = 1 / distance_matrix
    np.fill_diagonal(inverse_distances, 0)
    
    # Initialize the heuristic measures matrix
    heuristics = np.zeros((n_nodes, n_nodes))
    
    # Calculate the heuristic measure for each edge
    for i in range(n_nodes):
        for j in range(n_nodes):
            if i != j:
                heuristics[i, j] = inverse_distances[i, j] * (1 / (distance_matrix[i, j] * (1 + node_connections[j])))
    
    # Normalize the heuristic measures so that they sum up to 1
    heuristics /= np.sum(heuristics)
    
    return heuristics
```
-----
