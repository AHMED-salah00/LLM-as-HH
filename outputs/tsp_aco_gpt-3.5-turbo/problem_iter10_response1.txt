Code description: I will modify the algorithm to introduce a new heuristic measure based on the average distance between the endpoints of each edge. This measure aims to capture the average proximity of the endpoints, which can provide insight into the compactness of the resulting tour. By considering both the inverse distance and the average distance, the scoring function will prioritize edges that have important endpoints, shorter distances, and compact arrangements.

```python
import numpy as np

def scoring_function(distance_matrix: np.ndarray) -> np.ndarray:
    """
    The heuristic measures indicate how promising is each edge before actually solving this TSP instance.
    
    Parameters
    ----------
    distance_matrix : np.ndarray
        The distance matrix of shape (n_nodes, n_nodes), where diagonal elements are set to inf.
    
    Returns
    -------
    heuristics: np.ndarray
        The heuristic measures of shape (n_nodes, n_nodes) for all edges. 
    """
    n_nodes = distance_matrix.shape[0]
    
    # Calculate the inverse distances
    inverse_distances = 1 / distance_matrix
    np.fill_diagonal(inverse_distances, 0)
    
    # Compute the degree of each node
    node_degrees = np.sum(distance_matrix != np.inf, axis=1) - 1 # Subtract 1 to exclude self-loop
    
    # Compute the average distance between endpoints
    avg_distances = (distance_matrix + distance_matrix.T) / 2
    
    # Initialize the edge importance measure matrix
    edge_importance = np.zeros((n_nodes, n_nodes))
    
    # Compute the edge importance measure for each edge
    for i in range(n_nodes):
        for j in range(n_nodes):
            if i != j:
                edge_importance[i, j] = inverse_distances[i, j] * (inverse_distances[i, i] + inverse_distances[j, j]) * (1 / avg_distances[i, j])
    
    # Normalize the edge importance measure so that they sum up to 1
    edge_importance /= np.sum(edge_importance)
    
    # Initialize the heuristic measures matrix
    heuristics = np.zeros((n_nodes, n_nodes))
    
    # Calculate the heuristic measure for each edge
    for i in range(n_nodes):
        for j in range(n_nodes):
            if i != j:
                heuristics[i, j] = edge_importance[i, j] * (inverse_distances[i, j] / (1 + node_degrees[j]))
    
    # Normalize the heuristic measures so that they sum up to 1
    heuristics /= np.sum(heuristics)
    
    return heuristics
```

