Code description: The modified scoring function aims to combine the strengths of both algorithm 1 and algorithm 2, while also introducing some additional improvements. It takes into account the distance, demand, position, and capacity constraints. The idea is to prioritize edges that are closer to the depot, have a high demand, and are within the vehicle capacity. Additionally, it penalizes infeasible solutions by assigning a lower heuristic measure to edges that exceed the capacity.

```python
import numpy as np

def scoring_function(distance_matrix: np.ndarray, demands: np.ndarray, CAPACITY: int) -> np.ndarray:
    n_nodes = distance_matrix.shape[0]
    
    # Initialize heuristics matrix
    heuristics = np.zeros((n_nodes, n_nodes))
    
    # Maximum values for normalization
    max_distance = np.max(distance_matrix)
    max_demand = np.max(demands[1:])
    
    # Weight parameters for distance, demand, position, and infeasibility penalty
    distance_weight = 0.3
    demand_weight = 0.3
    position_weight = 0.2
    penalty_weight = 0.2
    
    # Calculate the position factor for each node
    positions = (np.arange(n_nodes) + 1) / n_nodes
    
    # Calculate heuristic measures for each edge
    for i in range(n_nodes):
        for j in range(i+1, n_nodes):
            distance = distance_matrix[i, j]
            demand = demands[j]
            
            # Calculate normalized distance, demand, and position
            normalized_distance = distance / max_distance
            normalized_demand = demand / max_demand
            normalized_position = positions[j]
            
            # Calculate heuristic score as weighted sum
            score = distance_weight * normalized_distance + demand_weight * normalized_demand + position_weight * normalized_position
            
            # Apply penalty for infeasible solutions
            if demand > CAPACITY:
                penalty = penalty_weight * (demand - CAPACITY) / CAPACITY
                score -= penalty
            
            # Update heuristics matrix
            heuristics[i, j] = score
    
    # Symmetrically set heuristics for the lower triangle of the matrix
    heuristics += np.tril(heuristics.T, -1)
    
    return heuristics
```

