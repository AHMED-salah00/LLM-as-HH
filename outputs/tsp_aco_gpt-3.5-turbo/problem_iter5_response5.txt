Code description: My solution is based on the idea of integrating local and global properties of the TSP instance to compute the heuristic measures. In this scoring function, I calculate the average distance of each node to other nodes using the inverse distance matrix. Then, I compute the node scores by summing the average distances, similar to Algorithm 1. Finally, I calculate the heuristic measures for each edge by multiplying the node scores with the average distances.

```python
import numpy as np

def scoring_function(distance_matrix):
    n_nodes = distance_matrix.shape[0]

    # Compute the inverse of the distance matrix
    inverse_distance_matrix = np.where(distance_matrix != 0, 1 / distance_matrix, 0)

    # Compute the average distance to other nodes for each node
    average_distance = np.sum(inverse_distance_matrix, axis=1) / (n_nodes - 1)

    # Repeat the average distances for each edge
    edge_average_distance = np.repeat(average_distance[:, np.newaxis], n_nodes, axis=1)

    # Compute the node scores by summing the average distances
    node_scores = np.sum(edge_average_distance, axis=1)

    # Repeat the node scores for each edge
    edge_scores = np.repeat(node_scores[:, np.newaxis], n_nodes, axis=1)

    # Compute the heuristic measures for each edge by multiplying node scores with average distances
    heuristics = edge_scores * edge_average_distance

    return heuristics
```
