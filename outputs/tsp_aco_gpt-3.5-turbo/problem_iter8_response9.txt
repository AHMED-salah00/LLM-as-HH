Code description: 

The provided code calculates heuristic measures for each edge in a TSP instance. It computes several measures based on the distance matrix, including inverse distance, node degree, edge centrality, average distance of connected nodes, edge diversity, hop count, and sum of distances to other nodes. The heuristic measures are then calculated by combining these measures and normalizing them.

```python
import numpy as np
from scipy.sparse import csr_matrix
from scipy.sparse.csgraph import floyd_warshall

def scoring_function(distance_matrix: np.ndarray) -> np.ndarray:
    """
    The heuristic measures indicate how promising is each edge before actually solving this TSP instance.
    
    Parameters
    ----------
    distance_matrix : np.ndarray
        The distance matrix of shape (n_nodes, n_nodes), where diagonal elements are set to inf.
    
    Returns
    -------
    heuristics: np.ndarray
        The heuristic measures of shape (n_nodes, n_nodes) for all edges. 
    """
    
    n_nodes = distance_matrix.shape[0]
    
    # Compute the inverse of the distance matrix
    inverse_distance_matrix = np.where(distance_matrix != 0, 1 / distance_matrix, 0)
    
    # Compute the degree of each node
    node_degrees = np.count_nonzero(distance_matrix, axis=1)
    
    # Compute the edge centrality measure
    edge_centrality = np.sum(inverse_distance_matrix, axis=1) / np.sum(inverse_distance_matrix)
    
    # Compute the average distance of connected nodes for each node
    connected_nodes_avg_distance = np.sum(inverse_distance_matrix, axis=1) / (n_nodes - 1)
    
    # Compute the edge diversity measure
    edge_diversity = np.sum((distance_matrix != 0), axis=1) / (n_nodes - 1)
    
    # Normalize the edge diversity measure
    normalized_edge_diversity = edge_diversity / np.max(edge_diversity)
    
    # Compute the hop count between nodes
    hop_count = floyd_warshall(csr_matrix(distance_matrix, dtype=np.float64))
    
    # Compute the sum of distances to other nodes for each node
    node_scores = np.sum(inverse_distance_matrix, axis=1)
    
    # Compute the heuristic measures
    heuristics = (
        inverse_distance_matrix 
        * (1 / node_degrees[:, np.newaxis]) 
        * hop_count 
        * connected_nodes_avg_distance[:, np.newaxis]
    ) / (node_scores[:, np.newaxis] ** 2)
    
    # Multiply the node degrees with the heuristic measures
    heuristics *= node_degrees[:, np.newaxis]
    
    # Multiply the edge centrality with the heuristic measures
    heuristics *= edge_centrality[:, np.newaxis]
    
    # Add the weighted average of edge diversity to the heuristic measures
    alpha = 0.2
    heuristics += alpha * normalized_edge_diversity[:, np.newaxis]
    
    # Normalize the heuristic measures
    heuristics /= np.sum(inverse_distance_matrix)
    
    return heuristics
```
