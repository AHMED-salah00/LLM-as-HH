Code description: The proposed scoring function aims to improve the previous algorithm by incorporating a normalization factor that adjusts the heuristic measures based on the maximum importance measure calculated for each node. This allows for a more balanced distribution of the heuristic values, ensuring that no individual node dominates the scoring process. Normalizing the heuristic measures helps to achieve a better overall evaluation of each edge's potential usefulness in the TSP instance.

```python
import numpy as np

def scoring_function(distance_matrix: np.ndarray) -> np.ndarray:
    """
    The heuristic measures indicate how promising is each edge before actually solving this TSP instance.

    Parameters
    ----------
    distance_matrix : np.ndarray
        The distance matrix of shape (n_nodes, n_nodes), where diagonal elements are set to inf.

    Returns
    -------
    heuristics: np.ndarray
        The heuristic measures of shape (n_nodes, n_nodes) for all edges. 
    """
    n_nodes = distance_matrix.shape[0]
    
    # Compute the inverse of the distance matrix
    inverse_distance_matrix = np.where(distance_matrix != 0, 1 / distance_matrix, 0)
    
    # Compute the degree centrality of each node
    degree_centrality = np.sum(inverse_distance_matrix, axis=1) / (n_nodes - 1)
    
    # Compute the total centrality of each node
    total_centrality = np.sum(inverse_distance_matrix, axis=1) / np.sum(inverse_distance_matrix)
    
    # Compute the edge importance measure
    edge_importance = inverse_distance_matrix * (degree_centrality[:, np.newaxis] + degree_centrality[np.newaxis, :])
    
    # Compute the maximum importance measure for each node
    max_importance = np.max(edge_importance, axis=1)
    
    # Calculate the modification factor based on the number of connections
    mod_factor = np.zeros((n_nodes, n_nodes))
    for j in range(n_nodes):
        mod_factor[:, j] = inverse_distance_matrix[:, j] / (1 + np.count_nonzero(distance_matrix[:, j]))
    
    # Calculate the heuristic measures
    heuristics = (edge_importance / max_importance[:, np.newaxis]) * mod_factor
    
    # Normalize the heuristic measures so that they sum up to 1
    heuristics /= np.sum(heuristics)
    
    return heuristics
```

