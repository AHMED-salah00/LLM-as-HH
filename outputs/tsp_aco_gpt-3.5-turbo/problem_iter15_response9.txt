Code description: This improved scoring function combines the ideas from both Algorithm 1 and Algorithm 2 to create a better scoring function. The scoring function calculates the inverse distances of each edge, similar to Algorithm 2. Additionally, it includes the degree centrality of the destination node, analogous to the degree centrality measure in Algorithm 1. The degree centrality measure indicates how well-connected the destination node is to other nodes, and we use it to prioritize edges with destination nodes that have a high degree centrality.

```python
import numpy as np
import networkx as nx

def scoring_function(distance_matrix: np.ndarray) -> np.ndarray:
    """
    The heuristic measures indicate how promising is each edge before actually solving this TSP instance.
    
    Parameters
    ----------
    distance_matrix : np.ndarray
        The distance matrix of shape (n_nodes, n_nodes), where diagonal elements are set to inf.
    
    Returns
    -------
    heuristics: np.ndarray
        The heuristic measures of shape (n_nodes, n_nodes) for all edges. 
    """
    n_nodes = distance_matrix.shape[0]
    
    # Compute the degree centrality of each node
    graph = nx.from_numpy_array(distance_matrix)
    degree_centrality = nx.degree_centrality(graph)
    
    # Calculate the inverse distances
    inverse_distances = 1 / distance_matrix
    np.fill_diagonal(inverse_distances, 0)
    
    # Initialize the heuristic measures matrix
    heuristics = np.zeros((n_nodes, n_nodes))
    
    # Calculate the heuristic measure for each edge
    for i in range(n_nodes):
        for j in range(n_nodes):
            if i != j:
                heuristics[i, j] = inverse_distances[i, j] * degree_centrality[j]
    
    # Normalize the heuristic measures so that they sum up to 1
    heuristics /= np.sum(heuristics)
    
    return heuristics
```

Note: This improved scoring function uses NetworkX library to compute the degree centrality of each node from the distance matrix.
