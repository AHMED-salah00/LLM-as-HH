Code description: 
This scoring function combines the ideas from Algorithm 1 and Algorithm 2 to provide a better heuristic measure. The scoring function takes into account the distance information, edge importance, and node connections to determine the heuristic measures for each edge. The distance information is considered through the inverse distance matrix as in Algorithm 2. The edge importance measure is calculated as the average of the node degrees of the source and destination nodes, capturing the relative importance of the edges. The node connections are considered as a penalty factor by multiplying the inverse distance by the inverse sum of the node connections for the source and destination nodes. This gives higher heuristic measures to edges with shorter distances and lower node connections.

```python
import numpy as np

def scoring_function(distance_matrix: np.ndarray) -> np.ndarray:
    """
    The heuristic measures indicate how promising is each edge before actually solving this TSP instance.
    
    Parameters
    ----------
    distance_matrix : np.ndarray
        The distance matrix of shape (n_nodes, n_nodes), where diagonal elements are set to inf.
    
    Returns
    -------
    heuristics: np.ndarray
        The heuristic measures of shape (n_nodes, n_nodes) for all edges. 
    """
    n_nodes = distance_matrix.shape[0]
    
    # Initialize the heuristic measures matrix
    heuristics = np.zeros((n_nodes, n_nodes))
    
    # Calculate the inverse distances
    inverse_distances = 1 / distance_matrix
    np.fill_diagonal(inverse_distances, 0)
    
    # Compute the node connections
    node_connections = np.sum(distance_matrix != np.inf, axis=1)

    # Compute the node degrees
    node_degrees = np.sum(distance_matrix != np.inf, axis=1) - 1
    
    # Calculate the edge importance measure
    edge_importance = (node_degrees[:, np.newaxis] + node_degrees) / (2 * np.max(node_degrees))
    
    # Calculate the heuristic measure for each edge
    for i in range(n_nodes):
        for j in range(n_nodes):
            if i != j:
                penalty_factor = 1 / (1 + node_connections[i] + node_connections[j])
                heuristics[i, j] = inverse_distances[i, j] * edge_importance[i, j] * penalty_factor
    
    # Normalize the heuristic measures so that they sum up to 1
    heuristics /= np.sum(heuristics)
    
    return heuristics
```
