Code description: In this improved scoring function, I will combine the ideas from the previous algorithms and introduce a new measure that takes into account the difference in degrees between connected nodes. The scoring function will calculate the inverse distances of each edge, similar to previous algorithms, and will incorporate the degree of nodes as well as the difference in degrees between connected nodes.

```python
import numpy as np

def scoring_function(distance_matrix: np.ndarray) -> np.ndarray:
    """
    The heuristic measures indicate how promising is each edge before actually solving this TSP instance.
    
    Parameters
    ----------
    distance_matrix : np.ndarray
        The distance matrix of shape (n_nodes, n_nodes), where diagonal elements are set to inf.
    
    Returns
    -------
    heuristics: np.ndarray
        The heuristic measures of shape (n_nodes, n_nodes) for all edges. 
    """
    n_nodes = distance_matrix.shape[0]
    
    # Calculate the inverse distances
    inverse_distances = 1 / distance_matrix
    np.fill_diagonal(inverse_distances, 0)
    
    # Compute the degree of each node
    node_degrees = np.sum(distance_matrix != np.inf, axis=1)
    
    # Calculate the average distance from each node to all other nodes
    average_distances = np.sum(distance_matrix, axis=1) / (n_nodes - 1)
    
    # Calculate the difference in degrees between connected nodes
    degree_differences = np.abs(node_degrees.reshape(-1, 1) - node_degrees)
    
    # Initialize the heuristic measures matrix
    heuristics = np.zeros((n_nodes, n_nodes))
    
    # Calculate the heuristic measure for each edge
    for i in range(n_nodes):
        for j in range(n_nodes):
            if i != j:
                heuristics[i, j] = inverse_distances[i, j] / (1 + node_degrees[j]) * average_distances[i] / (1 + degree_differences[i, j])
    
    # Normalize the heuristic measures so that they sum up to 1
    heuristics /= np.sum(heuristics)
    
    return heuristics
```

