Code description: The improved algorithm takes into account distance, demand, position, and capacity constraints to assign heuristic measures to edges. It aims to prioritize edges that are closer to the depot, have a higher demand, and are within the vehicle capacity. To achieve this, the algorithm calculates a score for each edge based on these factors and assigns higher scores to more promising edges. Additionally, infeasible solutions that exceed the vehicle capacity are penalized by assigning lower scores. The final heuristic measure is computed by summing up the weighted scores.

```python
import numpy as np

def scoring_function(distance_matrix: np.ndarray, demands: np.ndarray, CAPACITY: int) -> np.ndarray:
    n_nodes = distance_matrix.shape[0]
    
    # Initialize heuristics matrix
    heuristics = np.zeros((n_nodes, n_nodes))
    
    # Maximum values for normalization
    max_distance = np.max(distance_matrix)
    max_demand = np.max(demands[1:])
    
    # Weight parameters for distance, demand, position, and infeasibility penalty
    distance_weight = 0.5
    demand_weight = 0.35
    position_weight = 0.1
    penalty_weight = 0.05
    
    # Calculate normalized demands and positions
    normalized_demands = demands[1:] / max_demand
    positions = np.arange(1, n_nodes) / n_nodes
    
    for i in range(n_nodes):
        for j in range(i+1, n_nodes):
            distance = distance_matrix[i, j]
            
            # Calculate normalized distance
            normalized_distance = distance / max_distance
            
            # Check capacity constraint
            if demands[j] > CAPACITY:
                heuristics[i, j] = 0
            else:
                # Calculate penalty factor
                penalty_factor = 1 - (demands[j] / CAPACITY)
                
                # Calculate heuristics measure
                heuristics[i, j] = (
                    distance_weight * normalized_distance +
                    demand_weight * normalized_demands[j-1] +
                    position_weight * positions[j-1] +
                    penalty_weight * penalty_factor
                )

    # Symmetrically set heuristics for the lower triangle of the matrix
    heuristics += np.tril(heuristics.T, -1)
    
    return heuristics
```

