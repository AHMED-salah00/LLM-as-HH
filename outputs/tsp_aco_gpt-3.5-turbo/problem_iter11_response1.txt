Code description: In this improved scoring function, I will combine the ideas from Algorithm 1 and Algorithm 2 to create a better scoring function. The scoring function will calculate the inverse distances of each edge and then incorporate both the distance and connectivity information of the destination node. The connectivity information will be calculated using the degree of the destination node and the number of common neighbors between the source and destination nodes. The heuristic measure for each edge will be the product of the inverse distance, inverse destination node degree, and inverse number of common neighbors. This way, the scoring function will prioritize edges that have a small distance, low connectivity of the destination node, and a small number of common neighbors between the source and destination nodes.

```python
import numpy as np
import networkx as nx

def scoring_function(distance_matrix: np.ndarray) -> np.ndarray:
    """
    The heuristic measures indicate how promising is each edge before actually solving this TSP instance.
    
    Parameters
    ----------
    distance_matrix : np.ndarray
        The distance matrix of shape (n_nodes, n_nodes), where diagonal elements are set to inf.
    
    Returns
    -------
    heuristics: np.ndarray
        The heuristic measures of shape (n_nodes, n_nodes) for all edges. 
    """
    n_nodes = distance_matrix.shape[0]
    
    # Calculate the inverse distances
    inverse_distances = 1 / distance_matrix
    np.fill_diagonal(inverse_distances, 0)
    
    # Construct the graph using the distance matrix
    graph = nx.from_numpy_array(distance_matrix)

    # Compute the degree of each node
    node_degrees = np.array([graph.degree(i) for i in range(n_nodes)])
    
    # Compute the number of common neighbors for each edge
    common_neighbors = np.zeros((n_nodes, n_nodes), dtype=int)
    for i in range(n_nodes):
        for j in range(n_nodes):
            common_neighbors[i, j] = len(list(nx.common_neighbors(graph, i, j)))
    
    # Initialize the heuristic measures matrix
    heuristics = np.zeros((n_nodes, n_nodes))
    
    # Calculate the heuristic measure for each edge
    for i in range(n_nodes):
        for j in range(n_nodes):
            if i != j:
                heuristics[i, j] = inverse_distances[i, j] * (1 / (node_degrees[j] * (common_neighbors[i, j] + 1)))
    
    # Normalize the heuristic measures so that they sum up to 1
    heuristics /= np.sum(heuristics)
    
    return heuristics
```

