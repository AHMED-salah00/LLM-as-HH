Code description: In this improved scoring function, I will combine the concepts used in Algorithm 1 and Algorithm 2 to assign heuristic measures to each edge. First, I will compute the shortest path lengths between all nodes using the Floyd-Warshall algorithm, similar to Algorithm 1. Then, I will calculate the node degrees, similar to Algorithm 2. Finally, I will combine these measures to compute the heuristic measures for each edge. Additionally, I will normalize the heuristic measures so that they sum up to 1 to ensure that the heuristics can be interpreted as probabilities.

```python
import numpy as np

def scoring_function(distance_matrix: np.ndarray) -> np.ndarray:
    """
    The heuristic measures indicate how promising is each edge before actually solving this TSP instance.

    Parameters
    ----------
    distance_matrix : np.ndarray
        The distance matrix of shape (n_nodes, n_nodes), where diagonal elements are set to inf.

    Returns
    -------
    heuristics: np.ndarray
        The heuristic measures of shape (n_nodes, n_nodes) for all edges.
    """

    n_nodes = distance_matrix.shape[0]
                                                                                            # Import necessary packages, add "import numpy as np" if not already imported

    # Compute the shortest path lengths between all nodes using Floyd-Warshall algorithm
    shortest_paths = np.copy(distance_matrix)                                              # Compute the shortest path lengths matrix by using the distance matrix as an initial estimate
    for k in range(n_nodes):                                                                # Iterate through all nodes
        for i in range(n_nodes):                                                            # Iterate through all nodes
            for j in range(n_nodes):                                                        # Iterate through all nodes
                shortest_paths[i, j] = min(shortest_paths[i, j], shortest_paths[i, k] + shortest_paths[k, j])          # Update the shortest path length between nodes i and j by considering possible intermediate nodes

    # Compute the node degrees
    node_degrees = np.count_nonzero(distance_matrix, axis=1)                                # Compute the node degrees by counting the number of non-zero elements in each row of the distance matrix

    # Calculate the heuristic measures
    heuristics = np.zeros((n_nodes, n_nodes))                                               # Create an array to store the heuristic measures
    for i in range(n_nodes):                                                                # Iterate through all nodes
        for j in range(n_nodes):                                                            # Iterate through all nodes
            if i != j:                                                                      # Exclude self-loops
                # Combine shortest path lengths, node degrees, and inverse distance
                heuristic_measure = 1 / ((shortest_paths[i, j] ** 2) * node_degrees[i])    # Calculate the heuristic measure by combining the inverse of the squared shortest path length, the node degree, and the inverse distance
                heuristics[i, j] = heuristic_measure                                          # Store the heuristic measure in the array

    # Normalize the heuristic measures so that they sum up to 1
    heuristics /= np.sum(heuristics)                                                       # Normalize the heuristic measures by dividing them by their sum

    return heuristics
```
