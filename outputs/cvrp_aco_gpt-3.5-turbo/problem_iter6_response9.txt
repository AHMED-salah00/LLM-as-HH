Code description: The improved scoring function combines the best features from Algorithm 1 and Algorithm 2 to create a more effective scoring function. It considers the distance, demand ratio, position, closeness to depot, and clustering factor. The distance, demand ratio, position, and closeness to depot are normalized, and the clustering factor is calculated using KMeans clustering. The heuristics are calculated based on these factors by assigning different weights to each factor. Additionally, the new scoring function incorporates the capacity constraint by penalizing edges that exceed the vehicle capacity.

```python
import numpy as np
from sklearn.cluster import KMeans

def scoring_function(distance_matrix: np.ndarray, demands: np.ndarray, CAPACITY: int) -> np.ndarray:
    n_nodes = distance_matrix.shape[0]
    max_distance = np.max(distance_matrix)
    max_demand = np.max(demands[1:])
    
    heuristics = np.zeros((n_nodes, n_nodes))
    
    distance_weight = 0.4
    demand_weight = 0.2
    position_weight = 0.1
    depot_closeness_weight = 0.2
    clustering_weight = 0.1
    capacity_penalty_factor = 0.5
    
    # Calculate clustering factor
    kmeans = KMeans(n_clusters=3)
    cluster_labels = kmeans.fit_predict(distance_matrix[1:, 1:])
    
    cluster_distances = np.zeros((n_nodes, n_nodes))
    for i in range(1, n_nodes):
        for j in range(i + 1, n_nodes):
            if cluster_labels[i-1] == cluster_labels[j-1]:
                cluster_distances[i, j] = distance_matrix[i, j]
                cluster_distances[j, i] = distance_matrix[j, i]
            else:
                cluster_distances[i, j] = max_distance
                cluster_distances[j, i] = max_distance
    
    # Calculate heuristic measures
    for i in range(1, n_nodes):
        for j in range(i + 1, n_nodes):
            distance = distance_matrix[i, j]
            demand_ratio = demands[j] / CAPACITY
            position = (j - 1) / (n_nodes - 1)
            depot_closeness = distance_matrix[i, 0] + distance_matrix[j, 0]
            cluster_distance = cluster_distances[i, j]
            
            # Normalize distance, demand, position, depot closeness
            normalized_distance = distance / max_distance
            normalized_demand_ratio = demand_ratio / max_demand
            normalized_position = position
            normalized_depot_closeness = depot_closeness / (2 * max_distance)
            
            if demand_ratio > 1:
                heuristics[i, j] = -1e9
            else:
                distance_ratio = 1 - normalized_distance
                clustering_factor = np.exp(-cluster_distance / max_distance)
                
                # Calculate capacity penalty
                if (demands[i] + demands[j] > CAPACITY):
                    capacity_penalty = capacity_penalty_factor
                else:
                    capacity_penalty = 0
                
                heuristics[i, j] = distance_weight * distance_ratio + demand_weight * normalized_demand_ratio + position_weight * normalized_position + depot_closeness_weight * normalized_depot_closeness + clustering_weight * clustering_factor - capacity_penalty
            
            # Symmetrically set heuristics for the lower triangle of the matrix
            heuristics[j, i] = heuristics[i, j]

    return heuristics
```

The new scoring function combines the normalization and weighting approach from Algorithm 1 with the capacity penalty feature from Algorithm 2. It calculates the clustering factor using KMeans clustering, and assigns weights to distance, demand ratio, position, depot closeness, and clustering factor. It also checks if the demand sum of two nodes exceeds the capacity, and applies a penalty factor accordingly. The scoring function outputs the heuristic measures by combining these factors into a single score for each edge.
