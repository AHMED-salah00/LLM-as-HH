Code description: The modified algorithm aims to select the next node based on a combination of uncertainty, distance, and the number of unvisited neighbors. It calculates a score for each unvisited node using these three factors, and then selects the node with the highest score as the next node to visit.

The modification involves using a weighted sum of the three factors to calculate the score instead of a linear combination. Additionally, a normalization step is introduced to scale the scores between 0 and 1, ensuring that each factor contributes equally to the final score.

```python
import numpy as np

def select_next_node(current_node: int, destination_node: int, unvisited_nodes: set, distance_matrix: np.ndarray) -> int:
    # Initialize variables
    max_score = -np.inf
    nxt_node = None
    
    # Calculate the number of unvisited neighbors for each unvisited node
    num_unvisited_neighbors = np.zeros(len(distance_matrix))
    for node in unvisited_nodes:
        num_unvisited_neighbors[node] = np.sum(distance_matrix[node,:] > 0)
    
    # Normalize the distance matrix
    normalized_distance_matrix = distance_matrix / np.max(distance_matrix)
    
    # Calculate the score for each unvisited node
    for node in unvisited_nodes:
        distance = normalized_distance_matrix[current_node][node]
        variability = np.std(normalized_distance_matrix[:, node])
        inverse_cv = 1 / ((variability + 1) / (np.mean(normalized_distance_matrix[:, node]) + 1))
        num_neighbors = num_unvisited_neighbors[node]
        
        # Calculate the weighted sum of the factors
        score = 0.4 * inverse_cv + 0.4 * (1 - distance) + 0.2 * (1 - num_neighbors)
        
        if score > max_score:
            max_score = score
            nxt_node = node
    
    return nxt_node
```

