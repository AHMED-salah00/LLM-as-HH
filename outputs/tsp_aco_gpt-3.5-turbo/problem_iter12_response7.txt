Code description: 
The provided algorithm combines the inverse distances calculation from Algorithm 2 with the heuristic measures calculation from Algorithm 1. In this mutation, I will modify the way the heuristic measures are calculated by considering a combination of inverse distances and neighboring connections. The heuristic measure of each edge will be computed as the sum of the inverse distance and the inverse number of connections of both the source and destination nodes. This will capture the importance of both distance and connectivity in determining the quality of each edge.

```python
import numpy as np

def scoring_function(distance_matrix: np.ndarray) -> np.ndarray:
    """
    The heuristic measures indicate how promising is each edge before actually solving this TSP instance.
    
    Parameters
    ----------
    distance_matrix : np.ndarray
        The distance matrix of shape (n_nodes, n_nodes), where diagonal elements are set to inf.
    
    Returns
    -------
    heuristics: np.ndarray
        The heuristic measures of shape (n_nodes, n_nodes) for all edges. 
    """
    n_nodes = distance_matrix.shape[0]
    
    # Initialize the heuristic measures matrix
    heuristics = np.zeros((n_nodes, n_nodes))
    
    # Calculate the inverse distances
    inverse_distances = 1 / distance_matrix
    np.fill_diagonal(inverse_distances, 0)
    
    # Compute the node connections
    node_connections = np.sum(distance_matrix != np.inf, axis=1)
    
    # Calculate the heuristic measure for each edge
    for i in range(n_nodes):
        for j in range(n_nodes):
            if i != j:
                heuristics[i, j] = inverse_distances[i, j] + (1 / (inverse_distances[i, j] * (1 + node_connections[i] + node_connections[j])))
    
    # Normalize the heuristic measures so that they sum up to 1
    heuristics /= np.sum(heuristics)
    
    return heuristics
```
