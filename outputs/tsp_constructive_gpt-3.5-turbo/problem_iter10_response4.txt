Code description: The code uses a novel selecting-next-node function for the solution construction process for the Traveling Salesman Problem (TSP). The function selects the next node to visit based on a combination of uncertainty and distance. It calculates the uncertainty score for each unvisited node, which is a measure of the variability in distances from that node to all other nodes. The function then assigns a weight to each unvisited node based on the uncertainty score and the distance between the current node and the unvisited node. The node with the highest weight is selected as the next node to visit.

```python
import numpy as np

def select_next_node(current_node: int, destination_node: int, unvisited_nodes: set, distance_matrix: np.ndarray) -> int:
    """
    Select the next node to visit from the unvisited nodes based on uncertainty and distance.
    
    Parameters
    ----------
    current_node : int
        The current node.
    destination_node : int
        The destination node to return to.
    unvisited_nodes : set
        The set of unvisited nodes.
    distance_matrix : np.ndarray
        The distance matrix of shape (n_nodes, n_nodes).
    
    Returns
    -------
    nxt_node : int
        The next node to visit.
    """
    distances = distance_matrix[current_node]
    uncertainty_scores = []
    weights = []
    
    for node in unvisited_nodes:
        distance = distances[node]
        variability = np.std(distance_matrix[:, node])
        inverse_cv = 1 / (variability / np.mean(distance_matrix[:, node]))  # Calculate the inverse coefficient of variation
        
        uncertainty_scores.append(inverse_cv)
        
        weights.append(inverse_cv + (1 / distance))  # Calculate the weight for each unvisited node
        
    max_weight = np.max(weights)
    top_weight_nodes = [node for node, weight in zip(unvisited_nodes, weights) if weight == max_weight]
    nxt_node = np.random.choice(top_weight_nodes)  # Select a random node with the highest weight

    return nxt_node
```
