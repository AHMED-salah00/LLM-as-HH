Code Description: The proposed improved algorithm aims to select the next node based on a combination of uncertainty and distance. Instead of using equal weights, this algorithm introduces novel weights for each factor. The uncertainty weight is calculated as the inverse of the coefficient of variation (CV) of the distances to other nodes from the current node, which represents the stability of distances. The distance weight is the inverse of the distance from the current node to each unvisited node. These weights are combined to calculate the total weight for each unvisited node, and the node with the highest weighted score will be selected as the next node to visit. This algorithm also maintains the level of randomness by selecting a random node from the top-weighted nodes.

```python
import numpy as np

def select_next_node(current_node: int, destination_node: int, unvisited_nodes: set, distance_matrix: np.ndarray) -> int:
    """
    Select the next node to visit from the unvisited nodes based on a combination of uncertainty and distance, with improved weights.
    
    Parameters
    ----------
    current_node : int
        The current node.
    destination_node : int
        The destination node to return to.
    unvisited_nodes : set
        The set of unvisited nodes.
    distance_matrix : np.ndarray
        The distance matrix of shape (n_nodes, n_nodes).
    
    Returns
    -------
    nxt_node : int
        The next node to visit.
    """
    distances = distance_matrix[current_node]
    uncertainty_scores = []
    weights = []
    nxt_node = -1
    
    for node in unvisited_nodes:
        distance = distances[node]
        variability = np.std(distance_matrix[:, node])
        inverse_cv = 1 / (variability / np.mean(distance_matrix[:, node]))  # Calculate the inverse coefficient of variation
        
        uncertainty_scores.append(inverse_cv)
        
        weights.append(inverse_cv + (1 / distance))  # Calculate the weight for each unvisited node
        
    max_weight = np.max(weights)
    top_weight_nodes = [node for node, weight in zip(unvisited_nodes, weights) if weight == max_weight]
    nxt_node = np.random.choice(top_weight_nodes)  # Select a random node with the highest weight

    return nxt_node
```

