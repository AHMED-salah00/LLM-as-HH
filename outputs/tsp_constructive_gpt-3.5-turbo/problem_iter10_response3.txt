-----
Code description: The proposed algorithm aims to select the next node based on both the local and global information. It considers the local distance between the current node and the unvisited nodes, as well as the global distance between all unvisited nodes. The algorithm selects the unvisited node that has the smallest average distance to the close neighbors of the current node.

```python
import numpy as np

def select_next_node(current_node: int, destination_node: int, unvisited_nodes: set, distance_matrix: np.ndarray) -> int:
    """
    Select the next node to visit from the unvisited nodes based on both local and global information.
    
    Parameters
    ----------
    current_node : int
        The current node.
    destination_node : int
        The destination node to return to.
    unvisited_nodes : set
        The set of unvisited nodes.
    distance_matrix : np.ndarray
        The distance matrix of shape (n_nodes, n_nodes).
    
    Returns
    -------
    nxt_node : int
        The next node to visit.
    """
    # Initialize variables
    min_avg_distance = np.inf
    best_node = None
    
    # Calculate the average distance between the current node and its neighbors
    neighbors = [node for node in unvisited_nodes if distance_matrix[current_node, node] < np.inf]
    avg_distance = np.mean([distance_matrix[current_node, node] for node in neighbors])
    
    # Iterate over unvisited nodes
    for node in unvisited_nodes:
        if node != current_node:
            # Calculate the average distance between the neighbors and the current unvisited node
            avg_distance_new = np.mean([distance_matrix[node, neigh] for neigh in neighbors])
            
            # Update the best_node if the average distance is smaller
            if avg_distance_new < min_avg_distance:
                min_avg_distance = avg_distance_new
                best_node = node
    
    nxt_node = best_node
    return nxt_node
```
-----
