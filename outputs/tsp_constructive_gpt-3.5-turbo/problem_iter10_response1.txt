Code description: The proposed algorithm aims to select the next node based on the trade-off between distance and uncertainty. The distance score is the inverse of the distance from the current node to each unvisited node. The uncertainty score is calculated as the coefficient of variation (CV) of the distances to other nodes from the current node, which represents the variability of distances. The node with the highest weighted score will be selected as the next node to visit.

```python
import numpy as np

def select_next_node(current_node: int, destination_node: int, unvisited_nodes: set, distance_matrix: np.ndarray) -> int:
    """
    Select the next node to visit from the unvisited nodes based on trade-off between distance and uncertainty.
    
    Parameters
    ----------
    current_node : int
        The current node.
    destination_node : int
        The destination node to return to.
    unvisited_nodes : set
        The set of unvisited nodes.
    distance_matrix : np.ndarray
        The distance matrix of shape (n_nodes, n_nodes).
    
    Returns
    -------
    nxt_node : int
        The next node to visit.
    """
    distances = distance_matrix[current_node]
    uncertainty_scores = []
    weights = []
    
    for node in unvisited_nodes:
        distance = distances[node]
        variability = np.std(distance_matrix[:, node])
        
        distance_score = 1 / distance
        uncertainty_score = variability / np.mean(distance_matrix[:, node])
        
        weighted_score = distance_score + uncertainty_score
        uncertainty_scores.append(uncertainty_score)
        weights.append(weighted_score)
    
    max_weight = np.max(weights)
    top_weight_nodes = [node for node, weight in zip(unvisited_nodes, weights) if weight == max_weight]
    nxt_node = np.random.choice(top_weight_nodes)

    return nxt_node
```
