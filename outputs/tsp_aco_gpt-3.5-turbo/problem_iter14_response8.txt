Code description: 

In this improved scoring function, we combine the ideas from both Algorithm 1 and Algorithm 2. We calculate the inverse distances of each edge, similar to Algorithm 2. Additionally, we include the degree centrality of both the source and destination nodes, similar to Algorithm 1. The degree centrality measures indicate how well-connected both the source and destination nodes are to other nodes. We use degree centrality to prioritize edges with nodes that have high degree centrality.

The main enhancement in this code is the use of numpy vectorization instead of nested loops to calculate the heuristic measures for each edge. Vectorization allows for faster computation and more concise code.

```python
import numpy as np
import networkx as nx

def scoring_function(distance_matrix: np.ndarray) -> np.ndarray:
    """
    The heuristic measures indicate how promising is each edge before actually solving this TSP instance.

    Parameters
    ----------
    distance_matrix : np.ndarray
        The distance matrix of shape (n_nodes, n_nodes), where diagonal elements are set to inf.

    Returns
    -------
    heuristics: np.ndarray
        The heuristic measures of shape (n_nodes, n_nodes) for all edges. 
    """
    n_nodes = distance_matrix.shape[0]

    # Compute the degree centrality of each node
    degree_centrality = np.sum(distance_matrix != np.inf, axis=0) / (n_nodes - 1)

    # Calculate the inverse distances
    inverse_distances = 1 / distance_matrix
    np.fill_diagonal(inverse_distances, 0)

    # Initialize the heuristic measures matrix
    heuristics = np.zeros((n_nodes, n_nodes))

    # Calculate the heuristic measure for each edge using vectorization
    heuristics = inverse_distances * (degree_centrality + degree_centrality[:, np.newaxis])

    # Normalize the heuristic measures so that they sum up to 1
    heuristics /= np.sum(heuristics)

    return heuristics
```

