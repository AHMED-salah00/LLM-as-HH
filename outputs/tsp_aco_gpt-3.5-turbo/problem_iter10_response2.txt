Code description: In this improved scoring function, I will combine the ideas from Algorithm 1 and Algorithm 2 to create a better scoring function. The scoring function will first calculate the inverse distances of each edge, similar to Algorithm 2. Then, instead of generating random permutations of nodes, I will use the heuristic measures calculated in Algorithm 1. The heuristic measures will now be obtained by multiplying the inverse distances with the heuristic measure of the destination node - the product of the inverse distance and the inverse number of connections. This way, I can take into account both the distance and the number of connections of the destination node, prioritizing edges that have a close destination node with fewer connections.

```python
import numpy as np

def scoring_function(distance_matrix: np.ndarray) -> np.ndarray:
    """
    The heuristic measures indicate how promising is each edge before actually solving this TSP instance.
    
    Parameters
    ----------
    distance_matrix : np.ndarray
        The distance matrix of shape (n_nodes, n_nodes), where diagonal elements are set to inf.
    
    Returns
    -------
    heuristics: np.ndarray
        The heuristic measures of shape (n_nodes, n_nodes) for all edges. 
    """
    n_nodes = distance_matrix.shape[0]
    
    # Compute the inverse of the distance matrix
    inverse_distances = 1 / distance_matrix
    np.fill_diagonal(inverse_distances, 0)
    
    # Calculate the heuristic measures
    heuristics = inverse_distances * (1 / (distance_matrix * (1 + np.count_nonzero(distance_matrix, axis=1)[:, np.newaxis])))
    
    return heuristics
```

