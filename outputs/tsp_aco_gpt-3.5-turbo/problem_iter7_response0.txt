Code description: 

In this improved scoring function, I will combine the ideas from Algorithm 1 and Algorithm 2 to design a new scoring function that incorporates both the inverse distance and node degree information. The key modifications include:

1. Degree of nodes: Incorporate the sum of the inverse of node degrees to capture the connectivity and importance of each node in the heuristic measures.

2. Normalize Distance Matrix: Normalize the distance matrix by dividing each element by the largest distance. This will ensure that the inverse distance values are normalized and can be compared between different instances.

3. Compute heuristic measures: Calculate the heuristic measures using the product of the inverse distance and inverse node degree values. This scoring function aims to balance the importance of both distance and connectivity.

4. Normalization: Divide each heuristic measure by the sum of all heuristic measures to normalize the output values.

```python
import numpy as np

def scoring_function(distance_matrix: np.ndarray) -> np.ndarray:
    """
    The heuristic measures indicate how promising is each edge before actually solving this TSP instance.
    
    Parameters
    ----------
    distance_matrix : np.ndarray
        The distance matrix of shape (n_nodes, n_nodes), where diagonal elements are set to inf.
    
    Returns
    -------
    heuristics: np.ndarray
        The heuristic measures of shape (n_nodes, n_nodes) for all edges. 
    """
    n_nodes = distance_matrix.shape[0]
    
    # Normalize the distance matrix
    normalized_distance_matrix = distance_matrix / np.max(distance_matrix)
    
    # Compute the inverse of the normalized distance matrix
    inverse_distance_matrix = np.where(normalized_distance_matrix != 0, 1 / normalized_distance_matrix, 0)
    
    # Compute the degree of each node
    node_degrees = np.sum(distance_matrix != np.inf, axis=1)
    
    # Compute the sum of inverse of degrees for each node
    node_degree_scores = np.sum(1 / node_degrees)
    
    # Initialize the heuristic measures matrix
    heuristics = np.zeros((n_nodes, n_nodes))
    
    # Compute the heuristic measures
    for i in range(n_nodes):
        for j in range(n_nodes):
            if i != j:
                # Calculate the heuristic measure using the product of inverse distance and inverse node degree
                heuristics[i, j] = inverse_distance_matrix[i, j] * (1 / node_degrees[j])
    
    # Divide each heuristic measure by the sum of all heuristic measures to normalize
    heuristics /= np.sum(heuristics)
    
    return heuristics
```
