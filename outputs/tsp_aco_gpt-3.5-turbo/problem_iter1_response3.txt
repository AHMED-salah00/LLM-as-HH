Code description: The scoring function I am going to design is called Greedy Heuristics Scoring. It assigns heuristic values to each edge in the distance matrix based on a greedy strategy. The heuristic measure for each edge is the inverse of its distance, similar to Algorithm 2. However, instead of normalizing the heuristic measures, I will use a greedy approach to assign higher heuristic scores to edges with smaller distances, and lower scores to edges with larger distances. This will allow the scoring function to prioritize edges with shorter distances, which are likely to be part of a good solution.

```python
import numpy as np

def scoring_function(distance_matrix: np.ndarray) -> np.ndarray:
    """
    The heuristic measures indicate how promising is each edge before actually solving this TSP instance.
    
    Parameters
    ----------
    distance_matrix : np.ndarray
        The distance matrix of shape (n_nodes, n_nodes), where diagonal elements are set to inf.
    
    Returns
    -------
    heuristics: np.ndarray
        The heuristic measures of shape (n_nodes, n_nodes) for all edges. 
    """
    n_nodes = distance_matrix.shape[0]
    
    # Initialize the heuristic measures matrix
    heuristics = np.zeros((n_nodes, n_nodes))
    
    # Calculate the heuristic measure for each edge
    for i in range(n_nodes):
        for j in range(n_nodes):
            if i != j:
                heuristics[i, j] = distance_matrix[i, j]
    
    # Normalize the heuristic measures so that they sum up to 1
    heuristics /= np.sum(heuristics)
    
    return heuristics
```
