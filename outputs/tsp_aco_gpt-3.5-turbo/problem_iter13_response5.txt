Code description: In this improved scoring function, I will combine the ideas from both Algorithm 1 and Algorithm 2 to create a better scoring function. The scoring function will calculate the inverse distances of each edge, similar to Algorithm 2. Additionally, I will include the number of common neighbors for the destination node, analogous to the common neighbor measure in Algorithm 1. The number of common neighbors measure indicates how many neighbors the destination node shares with other nodes, and we will use it to prioritize edges with destination nodes that have a high number of common neighbors.

```python
import numpy as np
import networkx as nx

def scoring_function(distance_matrix: np.ndarray) -> np.ndarray:
    """
    The heuristic measures indicate how promising is each edge before actually solving this TSP instance.
    
    Parameters
    ----------
    distance_matrix : np.ndarray
        The distance matrix of shape (n_nodes, n_nodes), where diagonal elements are set to inf.
    
    Returns
    -------
    heuristics: np.ndarray
        The heuristic measures of shape (n_nodes, n_nodes) for all edges. 
    """
    n_nodes = distance_matrix.shape[0]
    
    # Calculate the inverse distances
    inverse_distances = 1 / distance_matrix
    np.fill_diagonal(inverse_distances, 0)
    
    # Construct the graph using the distance matrix
    graph = nx.from_numpy_array(distance_matrix)
    
    # Compute the number of common neighbors for each edge
    common_neighbors = np.zeros((n_nodes, n_nodes), dtype=int)
    for i in range(n_nodes):
        for j in range(n_nodes):
            common_neighbors[i, j] = len(list(nx.common_neighbors(graph, i, j))))
    
    # Initialize the heuristic measures matrix
    heuristics = np.zeros((n_nodes, n_nodes))
    
    # Calculate the heuristic measure for each edge
    for i in range(n_nodes):
        for j in range(n_nodes):
            if i != j:
                heuristics[i, j] = inverse_distances[i, j] * common_neighbors[j, j]
    
    # Normalize the heuristic measures so that they sum up to 1
    heuristics /= np.sum(heuristics)
    
    return heuristics
```

