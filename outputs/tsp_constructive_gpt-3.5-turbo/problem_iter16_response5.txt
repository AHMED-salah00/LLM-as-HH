Code description: In this code, I propose a novel selecting-next-node function called "Distance-based Exploration". This heuristic balances the exploration and exploitation of the distance information available from the current node to each unvisited node to make informed decisions about the next node to visit.

```python
import numpy as np

def select_next_node(current_node: int, destination_node: int, unvisited_nodes: set, distance_matrix: np.ndarray) -> int:
    # Calculate distance from current node to each unvisited node
    current_distances = distance_matrix[current_node, list(unvisited_nodes)]
    
    # Calculate the average distance
    average_distance = np.mean(current_distances)
    
    # Calculate the normalized distances relative to the average distance
    normalized_distances = current_distances / average_distance
    
    # Calculate the exploitation score for each node
    exploitation_scores = distance_matrix[current_node, list(unvisited_nodes)] / normalized_distances
    
    # Calculate the exploration score for each node
    exploration_scores = 1 / (distance_matrix[current_node, list(unvisited_nodes)] * normalized_distances)
    
    # Calculate the combined scores for each node
    combined_scores = exploitation_scores + exploration_scores
    
    # Sort the nodes based on combined scores in descending order
    sorted_nodes = sorted(list(unvisited_nodes), key=lambda node: combined_scores[node], reverse=True)
    
    # Select the node with the highest combined score
    nxt_node = sorted_nodes[0]
    
    return nxt_node
```
```
