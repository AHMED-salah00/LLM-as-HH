Code description: In this algorithm, we aim to balance the importance of distance and number of unvisited neighbors while selecting the next node. We calculate a score for each unvisited node by normalizing the distance and the number of unvisited neighbors, and then taking their weighted average. The weight factor can be adjusted to prioritize either distance or number of unvisited neighbors. We select the node with the highest score as the next node to visit.

```python
import numpy as np

def select_next_node(current_node: int, destination_node: int, unvisited_nodes: set, distance_matrix: np.ndarray) -> int:
    # Initialize variables
    max_score = -np.inf
    nxt_node = None
    weight = 0.5
    
    # Calculate the score for each unvisited node
    for node in unvisited_nodes:
        distance = distance_matrix[current_node][node]
        num_unvisited_neighbors = np.sum(distance_matrix[node,:] > 0)
        distance_norm = distance / np.max(distance_matrix)
        neighbors_norm = num_unvisited_neighbors / np.max(distance_matrix)
        
        score = (1 - weight) * distance_norm + weight * neighbors_norm
        
        if score > max_score:
            max_score = score
            nxt_node = node
    
    return nxt_node
```
The algorithm first calculates the maximum distance in the distance matrix using np.max(distance_matrix). Then, it normalizes the distance and the number of unvisited neighbors by dividing them by the maximum distance. The score is calculated as a weighted average of the normalized distance and the normalized number of unvisited neighbors. The node with the highest score is selected as the next node to visit.
