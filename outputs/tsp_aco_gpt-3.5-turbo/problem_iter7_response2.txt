Code description: In this novel scoring function, I will combine the features from Algorithm 1 and Algorithm 2 to create a more effective heuristic. The scoring function will consider the degree of nodes, hop count between nodes, centrality score, node scores based on the number of connections and inverse distances, and the average distances. Additionally, I will optimize the calculation of the hop count using the networkx library to compute the shortest path lengths between nodes.

```python
import numpy as np
import networkx as nx

def scoring_function(distance_matrix: np.ndarray) -> np.ndarray:
    """
    The heuristic measures indicate how promising is each edge before actually solving this TSP instance.
    
    Parameters
    ----------
    distance_matrix : np.ndarray
        The distance matrix of shape (n_nodes, n_nodes), where diagonal elements are set to inf.
    
    Returns
    -------
    heuristics: np.ndarray
        The heuristic measures of shape (n_nodes, n_nodes) for all edges. 
    """
    
    n_nodes = distance_matrix.shape[0]
    
    # Compute the inverse of the distance matrix
    inverse_distance_matrix = np.where(distance_matrix != 0, 1 / distance_matrix, 0)
    
    # Compute the degree of each node
    node_degrees = np.count_nonzero(distance_matrix, axis=1)
    
    # Compute the hop count between nodes using networkx library
    graph = nx.from_numpy_array(distance_matrix)
    hop_count = nx.floyd_warshall(graph)
    
    # Compute the centrality score of each node
    centrality_score = nx.degree_centrality(graph)
    
    # Compute the node scores based on the inverse distances and number of connections
    node_scores = np.sum(inverse_distance_matrix, axis=1) * (1 + node_degrees)
    
    # Compute the average distances to other nodes for each node
    average_distance = np.sum(inverse_distance_matrix, axis=1) / (n_nodes - 1)
    
    # Compute the heuristic measures
    heuristics = (inverse_distance_matrix * (1 / node_degrees[:, np.newaxis]) * hop_count * centrality_score[node_degrees] * node_scores[:, np.newaxis] * average_distance[node_degrees]) / np.sum(inverse_distance_matrix)
    
    return heuristics
```

This code combines various features from both Algorithm 1 and Algorithm 2 to create a novel scoring function. It calculates the degree of each node, hop count between nodes using networkx library, centrality score, node scores based on the inverse distances and number of connections, and average distances for each node. These factors are combined together to compute the heuristic measures for each edge.
