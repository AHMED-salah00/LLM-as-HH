Code description: In this improved scoring function, I propose to modify the computation of node scores and incorporate the node degree from Algorithm 1 into the heuristic measures computation of Algorithm 2. By considering both the hop count and node degree, we aim to capture the local properties of the TSP instance effectively. Additionally, we will normalize the heuristic measures to have a value between 0 and 1.

```python
import numpy as np
import networkx as nx

def scoring_function(distance_matrix: np.ndarray) -> np.ndarray:
    """
    The heuristic measures indicate how promising is each edge before actually solving this TSP instance.
    
    Parameters
    ----------
    distance_matrix : np.ndarray
        The distance matrix of shape (n_nodes, n_nodes), where diagonal elements are set to inf.
    
    Returns
    -------
    heuristics: np.ndarray
        The heuristic measures of shape (n_nodes, n_nodes) for all edges. 
    """
    
    n_nodes = distance_matrix.shape[0]
    
    # Compute the inverse of the distance matrix
    inverse_distance_matrix = np.where(distance_matrix != 0, 1 / distance_matrix, 0)
    
    # Compute the hop count between nodes
    hop_count = np.zeros((n_nodes, n_nodes), dtype=int)
    
    # Construct the graph using distance matrix
    graph = nx.from_numpy_matrix(distance_matrix, create_using=nx.Graph)
    
    # Calculate shortest path lengths using networkx library
    path_lengths = dict(nx.all_pairs_shortest_path_length(graph))
    
    # Compute the hop count
    for i in range(n_nodes):
        for j in range(n_nodes):
            hop_count[i, j] = path_lengths[i][j]
    
    # Compute the sum of distances to other nodes for each node
    node_scores = np.sum(inverse_distance_matrix, axis=1)
    
    # Calculate node degree
    node_degree = np.sum(distance_matrix != np.inf, axis=1)
    
    # Repeat the node scores and node degree for each edge
    edge_scores = np.repeat(node_scores[:, np.newaxis], n_nodes, axis=1)
    edge_degree = np.repeat(node_degree[:, np.newaxis], n_nodes, axis=1)
    
    # Compute the heuristic measures for each edge by combining hop count and node degree
    heuristics = (hop_count + 1) * edge_degree
    
    # Normalize the heuristic measures to have values between 0 and 1
    heuristics = heuristics / np.max(heuristics)
    
    return heuristics
```


