Code description: In this code, I propose a novel algorithm that combines the ideas from both Algorithm 1 and Algorithm 2 to create a better heuristic for selecting the next node. The algorithm considers factors such as direct distance, destination distance, Modified Greedy Squeezing distance, average neighbor distance, and neighbor priority to calculate a score for each unvisited node. The node with the highest score is then selected as the next node to visit.

```python
import numpy as np

def select_next_node(current_node: int, destination_node: int, unvisited_nodes: set, distance_matrix: np.ndarray) -> int:
    # Calculate direct distance from current node to each unvisited node
    direct_distances = distance_matrix[current_node, list(unvisited_nodes)]
    
    # Calculate distance from destination node to each unvisited node
    destination_distances = distance_matrix[destination_node, list(unvisited_nodes)]
    
    # Calculate Modified Greedy Squeezing distance for each unvisited node
    mgs_distance = {}
    for node in unvisited_nodes:
        direct_distance = distance_matrix[current_node, destination_node]
        node_distance = distance_matrix[current_node, node]
        
        # Calculate the weight based on the number of neighboring unvisited nodes
        weight = 1
        for neighbor in unvisited_nodes:
            if neighbor != node and neighbor in distance_matrix[node]:
                weight += 1

        mgs_distance[node] = direct_distance / (node_distance * weight)
        
    # Calculate average neighbor distance for each unvisited node
    neighbor_distance = {}
    for node in unvisited_nodes:
        neighbor_distances = distance_matrix[node, list(unvisited_nodes - set([node]))]
        neighbor_distance[node] = np.mean(neighbor_distances)
        
    # Calculate Neighbor Priority for each unvisited node
    neighbor_priority = {}
    for node in unvisited_nodes:
        neighbor_priority[node] = np.sum(distance_matrix[node, list(unvisited_nodes - set([node]))]) / len(unvisited_nodes - set([node]))
    
    # Calculate combined scores for each unvisited node
    combined_scores = 0.3 * direct_distances + 0.25 * destination_distances + 0.15 * np.array(list(mgs_distance.values())) + 0.15 * np.array(list(neighbor_distance.values())) + 0.15 * np.array(list(neighbor_priority.values()))
    
    # Find the node with the highest combined score
    nxt_node = list(unvisited_nodes)[np.argmax(combined_scores)]
    
    return nxt_node
```

The combined algorithm takes into account factors such as direct distance, destination distance, Modified Greedy Squeezing distance, average neighbor distance, and neighbor priority to calculate a combined score for each unvisited node. With proper weightings, the algorithm aims to select the most promising next node to visit.
