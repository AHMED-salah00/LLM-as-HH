Code description: In this improved scoring function, I will consider both the distance and demand factors to calculate the heuristic measure for each edge. The heuristic measure will be the product of two factors: the inverse of the distance and the demand ratio. However, unlike the original algorithms, I will assign different weights to the distance and demand factors to prioritize one over the other. The weights can be adjusted to give more importance to either the distance or demand factor. Additionally, I will initialize the heuristics matrix outside of the loop for efficiency.


```python
import numpy as np

def scoring_function(distance_matrix: np.ndarray, demands: np.ndarray, CAPACITY: int) -> np.ndarray:
    n_nodes = distance_matrix.shape[0]
    
    max_distance = np.max(distance_matrix)
    
    heuristics = np.zeros((n_nodes, n_nodes))
    
    distance_weight = 0.5  # Weight for the distance factor
    demand_weight = 0.5  # Weight for the demand factor
    
    for i in range(1, n_nodes):
        for j in range(i + 1, n_nodes):
            distance = distance_matrix[i, j]
            demand_ratio = demands[j] / CAPACITY
            
            if demand_ratio > 1:
                heuristics[i, j] = 0
            else:
                inverted_distance = 1 / distance
                heuristic_measure = inverted_distance ** distance_weight * demand_ratio ** demand_weight
                heuristics[i, j] = heuristic_measure
            
            # Symmetrically set heuristics for the lower triangle of the matrix
            heuristics[j, i] = heuristics[i, j]
    
    return heuristics
```

