Code description: In this code, I will propose a new algorithm that combines the ideas from Algorithm 1 and Algorithm 2 to select the next node. The goal is to select the node that minimizes the ratio of the Modified Greedy Squeezing distance and the average edge weight. This ratio takes into account both the distance to the destination node and the potential for further exploration.

I will start by initializing the next node variable (nxt_node) to None and the minimum ratio variable (min_ratio) to infinity. Then, I will iterate through all unvisited nodes to calculate the Modified Greedy Squeezing distance for each node. For each node, I will calculate the direct distance to the destination node, the distance to the current node, and the weight based on the number of neighboring unvisited nodes.

Next, I will calculate the average edge weight for all unvisited nodes. Then, I will calculate the ratio of the Modified Greedy Squeezing distance and the average edge weight for each node. If the calculated ratio is smaller than the minimum ratio found so far, I will update the minimum ratio and assign the unvisited node as the next node to visit.

Finally, I will return the next node as the output of the function.

```python
import numpy as np

def select_next_node(current_node: int, destination_node: int, unvisited_nodes: set, distance_matrix: np.ndarray) -> int:
    """
    Select the next node to visit from the unvisited nodes.
    
    Parameters
    ----------
    current_node : int
        The current node.
    destination_node : int
        The destination node to return to.
    unvisited_nodes : set
        The set of unvisited nodes.
    distance_matrix : np.ndarray
        The distance matrix of shape (n_nodes, n_nodes).
    
    Returns
    -------
    nxt_node : int
        The next node to visit.
    """
    
    nxt_node = None
    min_ratio = float('inf')
    
    mgs_distance = {}
    for node in unvisited_nodes:
        direct_distance = distance_matrix[current_node][destination_node]
        node_distance = distance_matrix[current_node][node]
        
        weight = 1
        for neighbor in unvisited_nodes:
            if neighbor != node and neighbor in distance_matrix[node]:
                weight += 1
        
        mgs_distance[node] = direct_distance / (node_distance * weight)
    
    average_edge_weight = np.mean(distance_matrix[current_node][list(unvisited_nodes)])
    
    for node in unvisited_nodes:
        ratio = mgs_distance[node] / average_edge_weight

        if ratio < min_ratio:
            min_ratio = ratio
            nxt_node = node
    
    return nxt_node
```

