Code description: The following code implements a novel selecting-next-node function called "Hybrid Distance Mod". This heuristic is a modification of the Hybrid Distance heuristic described above. 

In the Hybrid Distance Mod heuristic, instead of using a manually tuned weighted sum to combine the insertion distance and the distance to the destination node, we will dynamically determine the weights based on the current state of the solution construction process. The weights will be adjusted to balance the exploration and exploitation based on the progress made towards the destination node.

```python
import numpy as np

def select_next_node(current_node: int, destination_node: int, unvisited_nodes: set, distance_matrix: np.ndarray) -> int:
    # Calculate the insertion distance for each unvisited node
    insertion_distances = []
    for node in unvisited_nodes:
        min_insertion_distance = float('inf')
        for i in range(len(unvisited_nodes) + 1):
            partial_tour = list(unvisited_nodes - {node})
            partial_tour.insert(i, node)
            
            insertion_distance = 0
            for j in range(len(partial_tour) - 1):
                insertion_distance += distance_matrix[partial_tour[j], partial_tour[j+1]]
            
            if insertion_distance < min_insertion_distance:
                min_insertion_distance = insertion_distance
        
        insertion_distances.append(min_insertion_distance)
    
    # Calculate the distances from the current node to the unvisited nodes
    distances_to_unvisited = distance_matrix[current_node][list(unvisited_nodes)]
    
    # Calculate the weights based on the progress towards the destination node
    progress = distances_to_unvisited / (distance_matrix[current_node][destination_node] + distances_to_unvisited)
    weights = 0.8 * progress + 0.2 * (1 - progress)
    
    # Calculate the combined weighted distances (hybrid distances) from the current node to the destination node through each unvisited node
    hybrid_distances = weights * np.array(insertion_distances) + (1 - weights) * distances_to_unvisited
    
    # Find the index of the unvisited node with the minimum hybrid distance
    min_index = np.argmin(hybrid_distances)
    
    # Get the actual unvisited node corresponding to the minimum index
    nxt_node = list(unvisited_nodes)[min_index]
    
    return nxt_node
```

Note: In the modification, we calculate the progress as the ratio of the distance from the current node to each unvisited node to the sum of the distance from the current node to the destination node and the distance from the current node to each unvisited node. The weights are then calculated based on this progress, with higher weights assigned to nodes closer to the destination. This allows the heuristic to prioritize exploration near the solution space and exploitation of nodes closer to the destination.
