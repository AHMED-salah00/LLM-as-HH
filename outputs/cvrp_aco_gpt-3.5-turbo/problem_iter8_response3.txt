Code description: In this improved scoring function, I will combine the factors from Algorithm 1 and Algorithm 2 to create a more effective scoring function. I will consider the distance, demand, position, and degree centrality factors from Algorithm 1, and also include the clustering factor from Algorithm 2. The weights of the factors will be adjusted to optimize their contributions to the final heuristic measures. Additionally, I will initialize the heuristics matrix outside the loop for efficiency.

```python
import numpy as np
import networkx as nx
from sklearn.cluster import KMeans

def scoring_function(distance_matrix: np.ndarray, demands: np.ndarray, CAPACITY: int) -> np.ndarray:
    n_nodes = distance_matrix.shape[0]
    
    heuristics = np.zeros((n_nodes, n_nodes))
    
    distance_weight = 0.35
    demand_weight = 0.15
    position_weight = 0.1
    degree_centrality_weight = 0.3
    clustering_weight = 0.1
    
    # Calculate the degree centrality of nodes
    adjacency_matrix = np.where(distance_matrix > 0, 1, 0)
    G = nx.from_numpy_array(adjacency_matrix)
    degree_centrality_values = list(nx.degree_centrality(G).values())
    
    max_distance = np.max(distance_matrix)
    max_demand = np.max(demands[1:])
    max_degree_centrality = np.max(degree_centrality_values)
    
    # Calculate clustering factor
    kmeans = KMeans(n_clusters=3)
    cluster_labels = kmeans.fit_predict(distance_matrix[1:, 1:])
    
    cluster_distances = np.zeros((n_nodes, n_nodes))
    for i in range(1, n_nodes):
        for j in range(i + 1, n_nodes):
            if cluster_labels[i-1] == cluster_labels[j-1]:
                cluster_distances[i, j] = distance_matrix[i, j]
                cluster_distances[j, i] = distance_matrix[j, i]
            else:
                cluster_distances[i, j] = max_distance
                cluster_distances[j, i] = max_distance
    
    for i in range(1, n_nodes):
        for j in range(i + 1, n_nodes):
            distance = distance_matrix[i, j]
            demand_ratio = demands[j] / CAPACITY
            position = j / (n_nodes - 1)
            degree_centrality = degree_centrality_values[j - 1]
            cluster_distance = cluster_distances[i, j]
            
            normalized_distance = distance / max_distance
            normalized_demand_ratio = demand_ratio / max_demand
            normalized_position = position
            normalized_degree_centrality = degree_centrality / max_degree_centrality
            normalized_cluster_distance = cluster_distance / max_distance
            
            heuristics[i, j] = (
                distance_weight * normalized_distance +
                demand_weight * normalized_demand_ratio +
                position_weight * normalized_position +
                degree_centrality_weight * normalized_degree_centrality +
                clustering_weight * normalized_cluster_distance
            )
            
            # Symmetrically set heuristics for the lower triangle of the matrix
            heuristics[j, i] = heuristics[i, j]
    
    return heuristics
```

