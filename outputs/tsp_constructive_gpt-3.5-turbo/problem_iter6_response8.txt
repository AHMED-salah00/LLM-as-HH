Begin by giving a concise and clear description of your code, followed by the code itself.

Code description: The code implements a novel heuristic called Weighted Distance and Uncertainty with Neighborhood Exploration. This heuristic selects the next node to visit based on the weighted distance from the current node to each unvisited node, considering both the uncertainty score and the degree of each unvisited node. In addition, it explores the neighborhood of the current node and considers the distance, uncertainty score, and degree of the neighboring nodes. The node with the highest weighted distance, considering all these factors, is selected as the next node to visit.

```python
import numpy as np

def select_next_node(current_node: int, destination_node: int, unvisited_nodes: set, distance_matrix: np.ndarray) -> int:
    """
    Select the next node to visit from the unvisited nodes using the Weighted Distance and Uncertainty with Neighborhood Exploration heuristic.
    
    Parameters
    ----------
    current_node : int
        The current node.
    destination_node : int
        The destination node to return to.
    unvisited_nodes : set
        The set of unvisited nodes.
    distance_matrix : np.ndarray
        The distance matrix of shape (n_nodes, n_nodes).
    
    Returns
    -------
    nxt_node : int
        The next node to visit.
    """
    
    n_nodes = len(distance_matrix)
    
    # Calculate the degree for each unvisited node
    degree = np.zeros(n_nodes)
    for node in unvisited_nodes:
        degree[node] = np.sum(distance_matrix[node,:] > 0)
    
    # Calculate the uncertainty scores for each unvisited node
    uncertainty_scores = np.zeros(n_nodes)
    for node in unvisited_nodes:
        variability = np.std(distance_matrix[:, node])
        uncertainty_scores[node] = variability
    
    # Calculate the weighted distances from the current node to each unvisited node, considering uncertainty score and degree
    weighted_distances = np.zeros(n_nodes)
    for node in unvisited_nodes:
        weighted_distance = distance_matrix[current_node, node] * degree[node] * uncertainty_scores[node]
        weighted_distances[node] = weighted_distance
    
    # Explore the neighborhood of the current node
    neighboring_nodes = set()
    for node in unvisited_nodes:
        if distance_matrix[current_node, node] > 0:
            neighboring_nodes.add(node)
    
    # Calculate the weighted distances from the neighboring nodes to each unvisited node, considering uncertainty score and degree
    for node in neighboring_nodes:
        for neighbor in unvisited_nodes:
            if distance_matrix[node, neighbor] > 0:
                weighted_distance = distance_matrix[node, neighbor] * degree[neighbor] * uncertainty_scores[neighbor]
                weighted_distances[neighbor] += weighted_distance
    
    # Select the node with the highest weighted distance as the next node to visit
    nxt_node = np.argmax(weighted_distances)
    
    return nxt_node
```

