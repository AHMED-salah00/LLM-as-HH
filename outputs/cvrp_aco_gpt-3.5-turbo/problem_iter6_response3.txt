Code description: The novel scoring function combines the best features from Algorithm 1 and Algorithm 2 to create a more effective scoring function. The scoring function takes into account the distance, demand, position, and capacity of each node to assign heuristic measures to edges. It also considers the clustering structure of the nodes and penalizes edges that exceed the vehicle capacity.

```python
import numpy as np
from sklearn.cluster import KMeans

def scoring_function(distance_matrix: np.ndarray, demands: np.ndarray, CAPACITY: int) -> np.ndarray:
    n_nodes = distance_matrix.shape[0]

    # Initialize heuristics matrix
    heuristics = np.zeros((n_nodes, n_nodes))

    # Maximum values for normalization
    max_distance = np.max(distance_matrix)
    max_demand = np.max(demands[1:])

    # Weight parameters for distance, demand, position, clustering, and capacity penalty
    distance_weight = 0.4
    demand_weight = 0.3
    position_weight = 0.1
    clustering_weight = 0.1
    capacity_penalty_weight = 0.1

    # Calculate normalized demands and positions
    normalized_demands = demands[1:] / max_demand

    # Calculate clustering factor
    kmeans = KMeans(n_clusters=3)
    cluster_labels = kmeans.fit_predict(distance_matrix[1:, 1:])

    cluster_distances = np.zeros((n_nodes, n_nodes))
    for i in range(1, n_nodes):
        for j in range(i + 1, n_nodes):
            if cluster_labels[i-1] == cluster_labels[j-1]:
                cluster_distances[i, j] = distance_matrix[i, j]
                cluster_distances[j, i] = distance_matrix[j, i]
            else:
                cluster_distances[i, j] = max_distance
                cluster_distances[j, i] = max_distance

    # Calculate heuristics measures
    for i in range(n_nodes):
        for j in range(i + 1, n_nodes):
            distance = distance_matrix[i, j]
            normalized_distance = distance / max_distance
            normalized_demand_i = normalized_demands[i-1]
            normalized_demand_j = normalized_demands[j-1]
            normalized_demand_ratio = normalized_demand_i + normalized_demand_j
            position = j / (n_nodes - 1)
            remaining_capacity = CAPACITY - demands[j]

            # Check capacity constraint
            if demands[j] > CAPACITY:
                heuristics[i, j] = 0
            else:
                inverted_distance = 1 / distance
                clustering_factor = np.exp(-cluster_distances[i, j] / max_distance)

                # Calculate capacity penalty factor
                capacity_penalty_factor = 0 if remaining_capacity >= 0 else np.abs(remaining_capacity) / CAPACITY

                # Calculate heuristics measure
                heuristics[i, j] = (
                    distance_weight * inverted_distance +
                    demand_weight * normalized_demand_ratio * inverted_distance +
                    position_weight * position +
                    clustering_weight * clustering_factor -
                    capacity_penalty_weight * capacity_penalty_factor
                )

    # Symmetrically set heuristics for the lower triangle of the matrix
    heuristics += np.tril(heuristics.T, -1)

    return heuristics
```

