Code description: In this code, I will combine the features from both algorithms and adjust the weight distribution to create a better scoring function. The modified scoring function will include the Euclidean distance between nodes, the degree centrality of nodes, and the spatial proximity of nodes. I will adjust the weights assigned to these factors to reflect their importance in the scoring function.

```python
import numpy as np
import networkx as nx
from sklearn.cluster import KMeans
from scipy.spatial import distance

def scoring_function(distance_matrix: np.ndarray, demands: np.ndarray, CAPACITY: int) -> np.ndarray:
    n_nodes = distance_matrix.shape[0]

    max_distance = np.max(distance_matrix)
    max_demand = np.max(demands[1:])

    heuristics = np.zeros((n_nodes, n_nodes))

    distance_weight = 0.5
    demand_weight = 0.2
    centrality_weight = 0.2
    spatial_weight = 0.1

    # Calculate degree centrality of each node
    G = nx.from_numpy_array(distance_matrix)
    centrality = nx.degree_centrality(G)

    # Calculate clustering factor
    kmeans = KMeans(n_clusters=3)
    cluster_labels = kmeans.fit_predict(distance_matrix[1:, 1:])

    cluster_distances = np.zeros((n_nodes, n_nodes))
    for i in range(1, n_nodes):
        for j in range(1, n_nodes):
            if cluster_labels[i-1] == cluster_labels[j-1]:
                cluster_distances[i, j] = distance_matrix[i, j]
            else:
                cluster_distances[i, j] = max_distance

    # Calculate heuristic measures
    for i in range(n_nodes):
        for j in range(n_nodes):
            if i != j:
                demand_sum = demands[i] + demands[j]
                euclidean_distance = distance_matrix[i, j]

                if i == 0:
                    normalized_demand = demands[j] / max_demand
                    position = (j - 1) / (n_nodes - 1)

                    heuristic_demand = normalized_demand ** demand_weight
                    heuristic_distance = distance_weight / euclidean_distance
                    heuristic_position = (1 - demand_weight - distance_weight) * position
                    heuristic_centrality = centrality[j] ** centrality_weight
                    heuristic_spatial = cluster_distances[i, j] / max_distance

                    heuristics[i, j] = (heuristic_demand + heuristic_distance + heuristic_position + heuristic_centrality + heuristic_spatial)
                elif j == 0:
                    normalized_demand = demands[i] / max_demand
                    position = (i - 1) / (n_nodes - 1)

                    heuristic_demand = normalized_demand ** demand_weight
                    heuristic_distance = distance_weight / euclidean_distance
                    heuristic_position = (1 - demand_weight - distance_weight) * position
                    heuristic_centrality = centrality[i] ** centrality_weight
                    heuristic_spatial = cluster_distances[i, j] / max_distance

                    heuristics[i, j] = (heuristic_demand + heuristic_distance + heuristic_position + heuristic_centrality + heuristic_spatial)
                else:
                    normalized_demand_sum = demand_sum / max_demand
                    position = (j - 1) / (n_nodes - 1)

                    heuristic_demand = normalized_demand_sum ** demand_weight
                    heuristic_distance = distance_weight / euclidean_distance
                    heuristic_position = (1 - demand_weight - distance_weight) * position
                    heuristic_centrality = centrality[j] ** centrality_weight
                    heuristic_spatial = cluster_distances[i, j] / max_distance

                    if demand_sum > CAPACITY:
                        capacity_penalty = CAPACITY / demand_sum
                        heuristic_capacity_penalty = 1 - centrality_weight * capacity_penalty
                        heuristics[i, j] = (heuristic_demand + heuristic_distance + heuristic_position + heuristic_centrality + heuristic_spatial) * heuristic_capacity_penalty
                    else:
                        heuristics[i, j] = (heuristic_demand + heuristic_distance + heuristic_position + heuristic_centrality + heuristic_spatial)

    return heuristics
```

