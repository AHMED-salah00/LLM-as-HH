Code description: In this selecting-next-node function, I will use the Minimum Spanning Tree (MST) heuristic to solve the Traveling Salesman Problem (TSP). The MST heuristic constructs a minimum spanning tree from the current node to all unvisited nodes, and then selects the node with the shortest distance to the current node as the next node to visit.

```python
import numpy as np
from scipy.sparse import csgraph

def select_next_node(current_node: int, destination_node: int, unvisited_nodes: set, distance_matrix: np.ndarray) -> int:
    """
    Select the next node to visit from the unvisited nodes using the Minimum Spanning Tree heuristic.
    
    Parameters
    ----------
    current_node : int
        The current node.
    destination_node : int
        The destination node to return to.
    unvisited_nodes : set
        The set of unvisited nodes.
    distance_matrix : np.ndarray
        The distance matrix of shape (n_nodes, n_nodes).
    
    Returns
    -------
    nxt_node : int
        The next node to visit.
    """
    # Create a sub-matrix containing only the rows and columns corresponding to the unvisited nodes
    unvisited_matrix = distance_matrix[list(unvisited_nodes)][:, list(unvisited_nodes)]
    
    # Compute the minimum spanning tree from the current node to all unvisited nodes
    spanning_tree = csgraph.minimum_spanning_tree(unvisited_matrix)
    
    # Find the indices of the edges in the minimum spanning tree
    tree_indices = np.where(spanning_tree > 0)
    
    # Convert the indices into node numbers
    tree_nodes = list(unvisited_nodes)[tree_indices[1]]
    
    # Calculate the distances between the current node and the nodes in the spanning tree
    distances = distance_matrix[current_node][tree_nodes]
    
    # Find the index of the node with the shortest distance to the current node
    min_distance_index = np.argmin(distances)
    
    # Get the corresponding node number
    nxt_node = tree_nodes[min_distance_index]
    
    return nxt_node
```

