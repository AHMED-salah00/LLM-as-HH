Code description: The proposed code aims to design a novel heuristic for selecting the next node to visit. 

This code combines elements from Algorithm 1 and Algorithm 2. It considers the distance between the current node and each unvisited node, similar to Algorithm 1. Additionally, it incorporates a probabilistic scoring mechanism to assign a probability to each unvisited node and select the next node probabilistically, similar to Algorithm 2. 

The code calculates the increase in distance if each unvisited node is selected and stores the nodes with the minimum increase. Then, it assigns a score to each of these minimum increase nodes based on their distance from the current node, distance from the destination node, and distance from the current node to the destination node. The scores are inverted to assign higher scores to nodes with smaller distances. Finally, the code selects the next node probabilistically based on the inverted scores.

```python
import numpy as np

def select_next_node(current_node: int, destination_node: int, unvisited_nodes: set, distance_matrix: np.ndarray) -> int:
    # Initialize variables
    min_increase = np.inf
    min_distance = np.inf
    selected_nodes = []
    
    # Iterate over unvisited nodes
    for node in unvisited_nodes:
        # Calculate the increase in distance if node is selected
        increase = distance_matrix[current_node, node] + distance_matrix[node, destination_node] - distance_matrix[current_node, destination_node]
        
        # If the increase is smaller or if the increase is the same but the distance is shorter
        if increase < min_increase:
            min_increase = increase
            selected_nodes = [node]
            min_distance = distance_matrix[current_node, node]
        elif increase == min_increase:
            if distance_matrix[current_node, node] < min_distance:
                selected_nodes = [node]
                min_distance = distance_matrix[current_node, node]
            elif distance_matrix[current_node, node] == min_distance:
                selected_nodes.append(node)
    
    scores = []
    
    # Calculate scores for selected nodes
    for node in selected_nodes:
        score = distance_matrix[current_node, node] + distance_matrix[node, destination_node] + distance_matrix[current_node, destination_node]
        scores.append(1/score)

    scores_sum = sum(scores)

    probabilities = [score/scores_sum for score in scores]

    nxt_node_idx = np.random.choice(len(selected_nodes), p=probabilities)
    nxt_node = selected_nodes[nxt_node_idx]
    
    return nxt_node
```

