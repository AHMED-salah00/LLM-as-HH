Code description: 
The goal of the proposed algorithm is to select the next node to visit based on both the attractiveness of each unvisited node and the number of unvisited neighbors. However, instead of calculating the attractiveness and the number of unvisited neighbors for each unvisited node, a pre-processing step is introduced to calculate these values in advance. This allows for faster computation during the selection process. The attractiveness is calculated as the difference between the distance to the destination node and the distance to the current node, while the number of unvisited neighbors is simply the number of unvisited nodes adjacent to each unvisited node.

```python
import numpy as np

def select_next_node(current_node: int, destination_node: int, unvisited_nodes: set, distance_matrix: np.ndarray) -> int:
    # Calculate the attractiveness and number of unvisited neighbors in advance
    attractiveness_dict = {}
    num_unvisited_neighbors_dict = {}
    
    for node in unvisited_nodes:
        distance_current = distance_matrix[current_node][node]
        distance_destination = distance_matrix[node][destination_node]
        attractiveness = distance_destination - distance_current
        attractiveness_dict[node] = attractiveness
        
        num_unvisited_neighbors = len(unvisited_nodes.intersection(set(np.nonzero(distance_matrix[node])[0])))
        num_unvisited_neighbors_dict[node] = num_unvisited_neighbors
    
    # Select the next node based on attractiveness and number of unvisited neighbors
    max_score = -np.inf
    nxt_node = None
    
    for node in unvisited_nodes:
        score = attractiveness_dict[node] + num_unvisited_neighbors_dict[node]
        
        if score > max_score:
            max_score = score
            nxt_node = node
        elif score == max_score:
            nxt_node = min(nxt_node, node)
    
    return nxt_node
```

