Code description: The proposed algorithm, named "Modified Constrained Degree and Distance" (MCDD), further improves upon the original algorithm by adding a penalty term based on the number of times a node has been visited. This penalty term encourages the algorithm to visit nodes that have been visited fewer times, promoting better exploration of the search space.

```python
import numpy as np

def select_next_node(current_node: int, destination_node: int, unvisited_nodes: set, distance_matrix: np.ndarray) -> int:
    """
    Select the next node to visit from the unvisited nodes using the Modified Constrained Degree and Distance heuristic.
    
    Parameters
    ----------
    current_node : int
        The current node.
    destination_node : int
        The destination node to return to.
    unvisited_nodes : set
        The set of unvisited nodes.
    distance_matrix : np.ndarray
        The distance matrix of shape (n_nodes, n_nodes).
    
    Returns
    -------
    nxt_node : int
        The next node to visit.
    """
    
    n_nodes = len(distance_matrix)
    
    # Calculate the degree for each unvisited node
    degree = np.zeros(n_nodes)
    for node in unvisited_nodes:
        degree[node] = np.sum(distance_matrix[node,:] > 0)
    
    # Calculate the distances from the current node to each unvisited node
    distances = distance_matrix[current_node, list(unvisited_nodes)]
    
    # Normalize the degree and distances
    degree_normalized = degree / np.max(degree)
    distances_normalized = distances / np.max(distances)
    
    # Calculate the number of times each unvisited node has been visited
    visit_count = np.zeros(n_nodes)
    for node in range(n_nodes):
        if node != destination_node:
            visit_count[node] = np.sum(distance_matrix[node,:] == 0)
    
    # Normalize the visit count
    visit_count_normalized = visit_count / np.max(visit_count)
    
    # Define the weights for degree, distance, and visit count
    degree_weight = 1.0
    distance_weight = 1.0
    visit_count_weight = 0.5  # Weight for the penalty term
    
    # Calculate the scores based on degree, distances, and visit count
    scores = degree_weight * degree_normalized + distance_weight * distances_normalized - visit_count_weight * visit_count_normalized
    
    # Select the node with the highest score as the next node to visit
    nxt_node = list(unvisited_nodes)[np.argmax(scores)]
    
    return nxt_node
```
