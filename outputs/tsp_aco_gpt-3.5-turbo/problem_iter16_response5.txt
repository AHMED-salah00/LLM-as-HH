Code description: In this updated scoring function, I will incorporate the ideas from both Algorithm 1 and Algorithm 2 to create a more effective scoring function. The scoring function will first compute the inverse distances of each edge, similar to Algorithm 2. Then, instead of calculating the inverse number of connections, I will calculate the degree centrality of each node as in Algorithm 2. Next, I will multiply the inverse distances with the degree centrality of the destination node to prioritize edges that have a close destination node with higher degree centrality. Finally, I will normalize the heuristic measures to ensure they sum up to 1.

```python
import numpy as np

def scoring_function(distance_matrix: np.ndarray) -> np.ndarray:
    """
    The heuristic measures indicate how promising is each edge before actually solving this TSP instance.
    
    Parameters
    ----------
    distance_matrix : np.ndarray
        The distance matrix of shape (n_nodes, n_nodes), where diagonal elements are set to inf.
    
    Returns
    -------
    heuristics: np.ndarray
        The heuristic measures of shape (n_nodes, n_nodes) for all edges. 
    """
    n_nodes = distance_matrix.shape[0]
    
    # Calculate the inverse distances
    inverse_distances = 1 / distance_matrix
    np.fill_diagonal(inverse_distances, 0)
    
    # Compute the degree centrality of each node
    degree_centrality = np.sum(inverse_distances, axis=1) / (n_nodes - 1)
    
    # Initialize the heuristic measures matrix
    heuristics = np.zeros((n_nodes, n_nodes))
    
    # Calculate the heuristic measure for each edge
    for i in range(n_nodes):
        for j in range(n_nodes):
            if i != j:
                heuristics[i, j] = inverse_distances[i, j] * degree_centrality[j]
    
    # Normalize the heuristic measures so that they sum up to 1
    heuristics /= np.sum(heuristics)
    
    return heuristics
```

The code first calculates the inverse distances of each edge by dividing 1 by the distances in the distance matrix. The diagonal elements are set to 0 to avoid division by zero. 

Next, the degree centrality of each node is computed by summing up the inverse distances of the edges connected to each node and dividing by the number of nodes minus 1. This provides a measure of how well-connected a node is in the graph.

Then, the heuristic measures matrix is initialized as an array of zeros.

For each edge (i, j), where i and j are the source and destination nodes respectively, the heuristic measure is calculated by multiplying the inverse distance between i and j with the degree centrality of node j. This combination of distance and degree centrality helps prioritize edges that have a close destination with higher degree centrality.

Finally, the heuristic measures are normalized by dividing them by their sum, ensuring they sum up to 1. This allows for a fair comparison between different heuristics.
