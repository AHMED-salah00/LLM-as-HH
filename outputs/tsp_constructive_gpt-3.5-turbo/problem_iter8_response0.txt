Code description: My code implements a selecting-next-node function for the Traveling Salesman Problem using a novel heuristic called "Probabilistic Greedy Insertion".

The Probabilistic Greedy Insertion heuristic is an extension of the Closest Insertion heuristic. It starts with the same initial solution that contains only two nodes: the starting node and a randomly selected unvisited node. At each step, instead of selecting the node that is closest to any of the nodes in the current solution, it selects the node probabilistically based on a weighted distance score.

The weighted distance score is calculated as the sum of the distances of the unvisited node to all the nodes in the current solution, weighted by their degrees. The degree of a node is the number of edges connected to it. In other words, the higher the degree of a node, the more influential it is in the calculation of the weighted distance score.

The node with the highest weighted distance score is selected as the next node to visit.

Here is the code:

```python
import numpy as np

def select_next_node(current_node: int, destination_node: int, unvisited_nodes: set, distance_matrix: np.ndarray) -> int:
    # Initialize the solution with the current_node and a randomly selected unvisited node
    solution = [current_node, next(iter(unvisited_nodes))]
    
    while len(solution) < len(distance_matrix):
        node_scores = np.zeros(len(distance_matrix))
        
        # Calculate the weighted distance score for each unvisited node
        for node in unvisited_nodes:
            node_scores[node] = np.sum(distance_matrix[node, solution]) * np.sum(distance_matrix[node, :])
        
        # Normalize the scores
        node_scores = node_scores / np.sum(node_scores)
        
        # Select the next node probabilistically based on the scores
        nxt_node = np.random.choice(list(unvisited_nodes), p=node_scores)
        
        # Add the selected node to the solution
        solution.append(nxt_node)
        
    # Return the next node to visit, which is the second node in the solution
    return solution[1]
```

