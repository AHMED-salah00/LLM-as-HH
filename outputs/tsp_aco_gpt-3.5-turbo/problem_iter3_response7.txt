The goal of this modified scoring function is to improve the heuristics by incorporating additional information. Specifically, we will introduce a concept called "betweenness centrality" that measures the importance of a node as a bridge between other nodes. The heuristic measure for each edge will be computed by taking the product of the inverse distance to the nearest neighbor, the betweenness centrality score of the starting node, and the average distance of connected nodes.

To implement this, we will use the networkx library to compute the betweenness centrality score for each node in the distance matrix. Then, we will iterate over all edges and compute the heuristic measure based on the formula mentioned above.

Here is the modified code:

```python
import numpy as np
import networkx as nx
from scipy.spatial.distance import squareform

def scoring_function(distance_matrix: np.ndarray) -> np.ndarray:
    """
    The heuristic measures indicate how promising is each edge before actually solving this TSP instance.
    
    Parameters
    ----------
    distance_matrix : np.ndarray
        The distance matrix of shape (n_nodes, n_nodes), where diagonal elements are set to inf.
    
    Returns
    -------
    heuristics: np.ndarray
        The heuristic measures of shape (n_nodes, n_nodes) for all edges. 
    """
    n_nodes = distance_matrix.shape[0]
    heuristics = np.zeros((n_nodes, n_nodes))
    
    # Find the nearest neighbor for each node
    nearest_neighbors = np.argmin(distance_matrix, axis=1)
    
    # Compute the inverse distance matrix
    inverse_distance_matrix = np.where(distance_matrix != 0, 1 / distance_matrix, 0)
    
    # Compute the sum of distances to other nodes for each node
    node_scores = np.sum(inverse_distance_matrix, axis=1)
    
    # Compute the average distance of connected nodes for each node
    connected_nodes_avg_distance = np.sum(inverse_distance_matrix, axis=1) / (n_nodes - 1)

    # Compute the betweenness centrality scores for each node
    graph = nx.from_numpy_array(distance_matrix)
    centrality_scores = nx.betweenness_centrality(graph)
    
    for i in range(n_nodes):
        for j in range(n_nodes):
            if i != j:
                neighbor = nearest_neighbors[i]
                heuristics[i][j] = (1 / distance_matrix[i][neighbor]) * centrality_scores[i] * connected_nodes_avg_distance[i]
    
    return heuristics
```

Note: Make sure to install the `networkx` library if you haven't already using the command `pip install networkx`.
