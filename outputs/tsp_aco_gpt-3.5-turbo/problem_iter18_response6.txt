Code description: 

In this improved scoring function, I will combine elements from both Algorithm 1 and Algorithm 2 to create a better heuristic measure. The scoring function will calculate the inverse distances as in Algorithm 2, and also consider the edge importance and node connections from Algorithm 1. To calculate the heuristic measures, I will multiply the inverse distance with the square root of the inverse number of connections for the destination node. Additionally, I will multiply the result with the square root of the average of the source and destination node degrees to incorporate edge importance. This way, the scoring function will give higher heuristic measures to edges with shorter distances, lower node connections, and higher node degrees. I will also normalize the heuristic measures so that they sum up to 1.

```python
import numpy as np

def scoring_function(distance_matrix: np.ndarray) -> np.ndarray:
    """
    The heuristic measures indicate how promising is each edge before actually solving this TSP instance.
    
    Parameters
    ----------
    distance_matrix : np.ndarray
        The distance matrix of shape (n_nodes, n_nodes), where diagonal elements are set to inf.
    
    Returns
    -------
    heuristics: np.ndarray
        The heuristic measures of shape (n_nodes, n_nodes) for all edges. 
    """
    n_nodes = distance_matrix.shape[0]
    
    # Initialize the heuristic measures matrix
    heuristics = np.zeros((n_nodes, n_nodes))
    
    # Compute the inverse distances
    inverse_distances = 1 / distance_matrix
    np.fill_diagonal(inverse_distances, 0)
    
    # Compute the node connections
    node_connections = np.sum(distance_matrix != np.inf, axis=1)
    
    # Compute the node degrees
    node_degrees = np.sum(distance_matrix != np.inf, axis=1) - 1
    
    # Calculate the edge importance measure
    edge_importance = np.sqrt(node_degrees[:, np.newaxis] * node_degrees) / np.max(node_degrees)
    
    # Calculate the heuristic measure for each edge
    for i in range(n_nodes):
        for j in range(n_nodes):
            if i != j:
                heuristics[i, j] = inverse_distances[i, j] * np.sqrt(1 / (1 + node_connections[j])) * np.sqrt((node_degrees[i] + node_degrees[j]) / (2 * np.max(node_degrees)))
    
    # Normalize the heuristic measures so that they sum up to 1
    heuristics /= np.sum(heuristics)
    
    return heuristics
```

***Note:*** The code can be more optimized by avoiding the loops and using numpy operations directly, but for the sake of readability, I have used loops in this implementation.
