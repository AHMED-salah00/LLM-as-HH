Code description: The crossover algorithm combines the ideas from Algorithm 1 and Algorithm 2 to create a better scoring function. The scoring function calculates the inverse distances of each edge, similar to Algorithm 2. Then, instead of generating random permutations of nodes, it uses the heuristic measures calculated in Algorithm 1. The heuristic measures are obtained by multiplying the inverse distances with the heuristic measure of the destination node - the product of the inverse distance and the inverse number of connections. This way, it takes into account both the distance and the number of connections of the destination node, prioritizing edges that have a close destination node with fewer connections. The code also incorporates the degree centrality and total centrality measures from Algorithm 2 to improve the accuracy of the heuristic measures.

```python
import numpy as np

def scoring_function(distance_matrix: np.ndarray) -> np.ndarray:
    """
    The heuristic measures indicate how promising is each edge before actually solving this TSP instance.
    
    Parameters
    ----------
    distance_matrix : np.ndarray
        The distance matrix of shape (n_nodes, n_nodes), where diagonal elements are set to inf.
    
    Returns
    -------
    heuristics: np.ndarray
        The heuristic measures of shape (n_nodes, n_nodes) for all edges. 
    """
    n_nodes = distance_matrix.shape[0]
    
    # Compute the inverse of the distance matrix
    inverse_distance_matrix = np.where(distance_matrix != 0, 1 / distance_matrix, 0)
    
    # Compute the inverse distances
    inverse_distances = 1 / distance_matrix
    np.fill_diagonal(inverse_distances, 0)
    
    # Initialize the heuristic measures matrix
    heuristics = np.zeros((n_nodes, n_nodes))
    
    # Calculate the heuristic measure for each edge
    for i in range(n_nodes):
        for j in range(n_nodes):
            if i != j:
                # Compute the edge importance measure
                edge_importance = inverse_distances[i, j] * np.mean(inverse_distances)
                
                # Compute the degree centrality of the destination node
                degree_centrality = np.sum(inverse_distances[:, j]) / np.sum(inverse_distances)
                
                # Compute the total centrality of the destination node
                total_centrality = np.sum(inverse_distances[j]) / np.sum(inverse_distances)
                
                # Calculate the heuristic measure using Algorithm 1 and Algorithm 2
                heuristics[i, j] = inverse_distances[i, j] * (degree_centrality * total_centrality) + (inverse_distances[i, j] * inverse_distance_matrix[i, j] * (1 + degree_centrality))
    
    # Normalize the heuristic measures so that they sum up to 1
    heuristics /= np.sum(heuristics)
    
    return heuristics
```

