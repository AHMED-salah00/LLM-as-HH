Code description: The improved scoring function combines the ideas from Algorithm 1 and Algorithm 2 to create a better scoring function. It considers the distance, demand ratio, position, closeness to depot, and clustering factor. The distance, demand ratio, position, and closeness to depot are normalized, and the clustering factor is calculated using KMeans clustering. The heuristics are calculated based on these factors by assigning different weights to each factor.

```python
import numpy as np
from sklearn.cluster import KMeans

def scoring_function(distance_matrix: np.ndarray, demands: np.ndarray, CAPACITY: int) -> np.ndarray:
    n_nodes = distance_matrix.shape[0]
    max_distance = np.max(distance_matrix)
    max_demand = np.max(demands[1:])
    
    heuristics = np.zeros((n_nodes, n_nodes))
    
    distance_weight = 0.4
    demand_weight = 0.2
    position_weight = 0.1
    depot_closeness_weight = 0.2
    clustering_weight = 0.1
    
    # Calculate clustering factor
    kmeans = KMeans(n_clusters=3)
    cluster_labels = kmeans.fit_predict(distance_matrix[1:, 1:])
    
    cluster_distances = np.zeros((n_nodes, n_nodes))
    for i in range(1, n_nodes):
        for j in range(i + 1, n_nodes):
            if cluster_labels[i-1] == cluster_labels[j-1]:
                cluster_distances[i, j] = distance_matrix[i, j]
                cluster_distances[j, i] = distance_matrix[j, i]
            else:
                cluster_distances[i, j] = max_distance
                cluster_distances[j, i] = max_distance
    
    # Calculate heuristic measures
    for i in range(1, n_nodes):
        for j in range(i + 1, n_nodes):
            distance = distance_matrix[i, j]
            demand_ratio = demands[j] / CAPACITY
            position = (j - 1) / (n_nodes - 1)
            depot_closeness = distance_matrix[i, 0] + distance_matrix[j, 0]
            cluster_distance = cluster_distances[i, j]
            
            # Normalize distance, demand, position, depot closeness
            normalized_distance = distance / max_distance
            normalized_demand_ratio = demand_ratio / max_demand
            normalized_position = position
            normalized_depot_closeness = depot_closeness / (2 * max_distance)
            
            if demand_ratio > 1:
                heuristics[i, j] = -1e9
            else:
                distance_ratio = 1 - normalized_distance
                clustering_factor = np.exp(-cluster_distance / max_distance)
                heuristics[i, j] = distance_weight * distance_ratio + demand_weight * normalized_demand_ratio + position_weight * normalized_position + depot_closeness_weight * normalized_depot_closeness + clustering_weight * clustering_factor
            
            # Symmetrically set heuristics for the lower triangle of the matrix
            heuristics[j, i] = heuristics[i, j]
    
    return heuristics
```
