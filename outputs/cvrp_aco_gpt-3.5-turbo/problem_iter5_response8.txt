Code description: 
In this improved scoring function, we will combine the best features from Algorithm 1 and Algorithm 2 to create a more effective scoring function. The new scoring function will consider the distance, demand, and clustering structure of each node to assign heuristic measures to each edge. Additionally, it will incorporate the capacity constraint by penalizing edges that exceed the vehicle capacity.

```python
import numpy as np
from sklearn.cluster import KMeans

def scoring_function(distance_matrix: np.ndarray, demands: np.ndarray, CAPACITY: int) -> np.ndarray:
    n_nodes = distance_matrix.shape[0]
    
    max_distance = np.max(distance_matrix)
    max_demand = np.max(demands[1:])
    
    heuristics = np.zeros((n_nodes, n_nodes))
    
    distance_weight = 0.5
    demand_weight = 0.4
    clustering_weight = 0.1
    capacity_penalty_factor = 0.5
    
    # Calculate clustering factor
    kmeans = KMeans(n_clusters=3)
    cluster_labels = kmeans.fit_predict(distance_matrix[1:, 1:])
    
    cluster_distances = np.zeros((n_nodes, n_nodes))
    for i in range(1, n_nodes):
        for j in range(i + 1, n_nodes):
            if cluster_labels[i-1] == cluster_labels[j-1]:
                cluster_distances[i, j] = distance_matrix[i, j]
                cluster_distances[j, i] = distance_matrix[j, i]
            else:
                cluster_distances[i, j] = max_distance
                cluster_distances[j, i] = max_distance
    
    # Calculate heuristic measures
    for i in range(1, n_nodes):
        for j in range(i + 1, n_nodes):
            distance = distance_matrix[i, j]
            demand_ratio = demands[j] / CAPACITY
            cluster_distance = cluster_distances[i, j]
            
            if demand_ratio > 1:
                heuristics[i, j] = 0
            else:
                inverted_distance = 1 / distance
                clustering_factor = np.exp(-cluster_distance / max_distance)
                
                if i == 0:
                    normalized_demand = demands[j] / max_demand
                    position = j / (n_nodes - 1)
                    
                    weight_distance = 0.4
                    weight_demand = 0.4
                    weight_position = 0.2
                    
                    heuristic_demand = normalized_demand / distance * weight_demand
                    heuristic_distance = weight_distance / distance
                    heuristic_position = weight_position * position
                    
                    heuristics[i, j] = distance_weight * inverted_distance + demand_weight * heuristic_demand + clustering_weight * clustering_factor + heuristic_position
                elif j == 0:
                    normalized_demand = demands[i] / max_demand
                    position = i / (n_nodes - 1)
                    
                    weight_distance = 0.4
                    weight_demand = 0.4
                    weight_position = 0.2
                    
                    heuristic_demand = normalized_demand / distance * weight_demand
                    heuristic_distance = weight_distance / distance
                    heuristic_position = weight_position * position
                    
                    heuristics[i, j] = distance_weight * inverted_distance + demand_weight * heuristic_demand + clustering_weight * clustering_factor + heuristic_position
                else:
                    normalized_demand_ratio = demands[i] / max_demand + demands[j] / max_demand
                    position = j / (n_nodes - 1)
                    
                    weight_distance = 0.3
                    weight_demand = 0.3
                    weight_position = 0.2
                    
                    heuristic_demand = normalized_demand_ratio / distance * weight_demand
                    heuristic_distance = weight_distance / distance
                    heuristic_position = weight_position * position
                    
                    # Check if the demand sum exceeds the capacity
                    if demands[i] + demands[j] > CAPACITY:
                        capacity_penalty = capacity_penalty_factor
                        heuristics[i, j] = distance_weight * inverted_distance + demand_weight * heuristic_demand + clustering_weight * clustering_factor + heuristic_position - capacity_penalty
                    else:
                        heuristics[i, j] = distance_weight * inverted_distance + demand_weight * heuristic_demand + clustering_weight * clustering_factor + heuristic_position
            
            # Symmetrically set heuristics for the lower triangle of the matrix
            heuristics[j, i] = heuristics[i, j]
    
    return heuristics
```

This new scoring function combines the distance, demand, and clustering structure of nodes to assign heuristic measures to edges. It also penalizes edges that exceed the capacity constraint. The weights and penalty factor can be customized to adjust the importance of each factor.
