Code description: The modified scoring function incorporates additional features such as node centrality, edge betweenness, and the average distance between connected nodes. Additionally, it optimizes the calculation of the hop count by using the networkx library to compute shortest path lengths between nodes.

```python
import numpy as np
import networkx as nx

def scoring_function(distance_matrix: np.ndarray) -> np.ndarray:
    """
    The heuristic measures indicate how promising is each edge before actually solving this TSP instance.

    Parameters
    ----------
    distance_matrix : np.ndarray
        The distance matrix of shape (n_nodes, n_nodes), where diagonal elements are set to inf.

    Returns
    -------
    heuristics: np.ndarray
        The heuristic measures of shape (n_nodes, n_nodes) for all edges.
    """
    n_nodes = distance_matrix.shape[0]

    # Compute the inverse of the distance matrix
    inverse_distance_matrix = np.where(distance_matrix != 0, 1 / distance_matrix, 0)

    # Compute the degree of each node
    node_degrees = np.count_nonzero(distance_matrix, axis=1)

    # Compute the hop count between nodes
    hop_count = np.zeros((n_nodes, n_nodes), dtype=int)
  
    # Construct the graph using the distance matrix
    graph = nx.from_numpy_matrix(distance_matrix, create_using=nx.Graph)

    # Calculate shortest path lengths using networkx library
    path_lengths = dict(nx.all_pairs_shortest_path_length(graph))

    # Compute the hop count
    for i in range(n_nodes):
        for j in range(n_nodes):
            hop_count[i, j] = path_lengths[i][j]

    # Compute the node scores
    node_scores = np.sum(inverse_distance_matrix, axis=1)

    # Compute the average distance of connected nodes
    connected_nodes_avg_distance = np.sum(inverse_distance_matrix, axis=1) / (n_nodes - 1)

    # Compute the edge centrality measure
    edge_centrality = np.sum(nx.edge_betweenness_centrality(graph).values()) / (n_nodes * (n_nodes - 1) / 2)

    # Repeat the node scores for each edge
    edge_scores = np.repeat(node_scores[:, np.newaxis], n_nodes, axis=1)

    # Calculate the heuristic measures
    heuristics = (
            (inverse_distance_matrix * hop_count * edge_scores) /
            (node_degrees[:, np.newaxis] * edge_scores ** 2 * connected_nodes_avg_distance[:, np.newaxis])
    )

    # Multiply the node degrees with the heuristic measures
    heuristics *= node_degrees[:, np.newaxis]

    # Multiply the edge centrality with the heuristic measures
    heuristics *= edge_centrality

    return heuristics
```

