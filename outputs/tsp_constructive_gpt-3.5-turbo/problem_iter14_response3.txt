Code description: The proposed crossover algorithm combines the dynamic weights adjustment from Algorithm 2 and the modified Greedy Squeezing distance from Algorithm 1. The algorithm calculates a score for each unvisited node, considering the modified Greedy Squeezing distance and the dynamic weights, and selects the node with the highest score as the next node to visit.

```python
import numpy as np

def select_next_node(current_node: int, destination_node: int, unvisited_nodes: set, distance_matrix: np.ndarray) -> int:
    # Calculate modified Greedy Squeezing distance for each unvisited node
    mgs_distance = {}
    for node in unvisited_nodes:
        direct_distance = distance_matrix[current_node, destination_node]
        node_distance = distance_matrix[current_node, node]
        
        # Calculate the weight based on the number of neighboring unvisited nodes
        weight = 1
        for neighbor in unvisited_nodes:
            if neighbor != node and neighbor in distance_matrix[node]:
                weight += 1

        mgs_distance[node] = direct_distance / (node_distance * weight)
        
    # Calculate the weights based on the progress towards the destination node
    progress = distance_matrix[current_node][list(unvisited_nodes)] / (distance_matrix[current_node][destination_node] + distance_matrix[current_node][list(unvisited_nodes)])
    weights = 0.8 * progress + 0.2 * (1 - progress)
    
    # Calculate combined scores for each unvisited node
    combined_scores = 0.4 * np.array(list(mgs_distance.values())) + 0.6 * weights
    
    # Find the node with the highest combined score
    nxt_node = list(unvisited_nodes)[np.argmax(combined_scores)]
    
    return nxt_node
```


