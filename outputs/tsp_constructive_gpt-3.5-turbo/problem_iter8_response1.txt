Code description: The proposed algorithm aims to combine elements from both Algorithm 1 and Algorithm 2 in order to improve the selection of the next node. It considers the increase in total distance and combines it with a weighted score based on the distance and uncertainty. The weight is calculated as the sum of the inverse of the distance and the uncertainty score, where a higher weight means a more favorable node.

```python
import numpy as np

def select_next_node(current_node: int, destination_node: int, unvisited_nodes: set, distance_matrix: np.ndarray) -> int:
    # Initialize variables
    min_increase = np.inf
    selected_nodes = []
    weights = []
    
    # Iterate over unvisited nodes
    for node in unvisited_nodes:
        # Calculate the increase in distance if node is selected
        increase = distance_matrix[current_node, node] + distance_matrix[node, destination_node] - distance_matrix[current_node, destination_node]
        
        # Calculate the weight for each unvisited node
        distance = distance_matrix[current_node, node]
        variability = np.std(distance_matrix[:, node])
        weight = 1 / distance + variability
        
        # If the increase is smaller or if the increase is the same but the weight is larger
        if increase < min_increase:
            min_increase = increase
            selected_nodes = [node]
            weights = [weight]
        elif increase == min_increase:
            if weight > weights[0]:
                selected_nodes = [node]
                weights = [weight]
            elif weight == weights[0]:
                selected_nodes.append(node)
                weights.append(weight)
    
    nxt_node = selected_nodes[np.argmin(weights)]
    return nxt_node
```
