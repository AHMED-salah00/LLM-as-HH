Code description: 
In this improved scoring function, I will focus on the idea of promoting exploration and diversity in the solution space. To achieve this, I will calculate the closeness centrality of each node and the harmonic centrality of each edge. The closeness centrality measures how close a node is to all other nodes, while the harmonic centrality measures the accessibility between nodes. By combining these two measures, the scoring function can prioritize edges that connect nodes with high closeness centrality and high harmonic centrality.

```python
import numpy as np
import networkx as nx

def scoring_function(distance_matrix: np.ndarray) -> np.ndarray:
    """
    The heuristic measures indicate how promising is each edge before actually solving this TSP instance.
    
    Parameters
    ----------
    distance_matrix : np.ndarray
        The distance matrix of shape (n_nodes, n_nodes), where diagonal elements are set to inf.
    
    Returns
    -------
    heuristics: np.ndarray
        The heuristic measures of shape (n_nodes, n_nodes) for all edges. 
    """
    n_nodes = distance_matrix.shape[0]
    
    # Compute the closeness centrality of each node
    G = nx.from_numpy_array(distance_matrix)
    closeness_centrality = nx.closeness_centrality(G)
    
    # Compute the harmonic centrality of each edge
    harmonic_centrality = np.zeros((n_nodes, n_nodes))
    
    for i in range(n_nodes):
        for j in range(n_nodes):
            if i != j:
                neighbors_i = G.neighbors(i)
                neighbors_j = G.neighbors(j)
                common_neigbors = len(set(neighbors_i).intersection(neighbors_j))
                harmonic_centrality[i, j] = 2 * common_neigbors / (len(neighbors_i) + len(neighbors_j))
    
    # Initialize the heuristic measures matrix
    heuristics = np.zeros((n_nodes, n_nodes))
    
    # Calculate the heuristic measure for each edge using vectorization
    for i in range(n_nodes):
        for j in range(n_nodes):
            if i != j:
                heuristics[i, j] = closeness_centrality[j] * harmonic_centrality[i, j]
    
    # Normalize the heuristic measures so that they sum up to 1
    heuristics /= np.sum(heuristics)
    
    return heuristics
```

Note: To calculate the harmonic centrality of each edge, I iterated over all pairs of nodes and checked for common neighbors, then used the formula `2 * common_neigbors / (len(neighbors_i) + len(neighbors_j))` to calculate the harmonic centrality value for the edge.
