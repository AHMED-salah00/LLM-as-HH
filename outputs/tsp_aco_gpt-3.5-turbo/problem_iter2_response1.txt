Code description: 
The crossover algorithm combines the approaches from both Algorithm 1 and Algorithm 2. It computes a novel scoring function by incorporating the inverse distances from Algorithm 2 and the cost calculations from Algorithm 1. The scoring function generates random permutations of the nodes and calculates the cost of each permutation using the distance matrix. The heuristic measures are obtained by multiplying the inverse distances with the inverse of the cost of each permutation. Additionally, this algorithm considers edge centrality by calculating the centrality score for each edge based on the sum of distances to other nodes. The final heuristic measures are obtained by multiplying the normalized heuristic measures from Algorithm 2 with the centrality score.

```python
import numpy as np

def scoring_function(distance_matrix: np.ndarray) -> np.ndarray:
    """
    The heuristic measures indicate how promising is each edge before actually solving this TSP instance.
    
    Parameters
    ----------
    distance_matrix : np.ndarray
        The distance matrix of shape (n_nodes, n_nodes), where diagonal elements are set to inf.
    
    Returns
    -------
    heuristics: np.ndarray
        The heuristic measures of shape (n_nodes, n_nodes) for all edges. 
    """
    n_nodes = distance_matrix.shape[0]
    heuristics = np.zeros((n_nodes, n_nodes))

    # Compute the inverse distances
    inverse_distances = 1 / distance_matrix
    np.fill_diagonal(inverse_distances, 0)
    total_sum = np.sum(inverse_distances)
    
    # Compute the sum of distances to other nodes for each node
    node_scores = np.sum(inverse_distances, axis=1)
    
    for i in range(n_nodes):
        for j in range(n_nodes):
            if i != j:
                permutations = np.random.permutation(n_nodes)
                cost = np.sum(distance_matrix[permutations[:-1], permutations[1:]])
                heuristic = inverse_distances[i, j] * (1 / cost)
                
                # Compute edge centrality score
                centrality_score = np.sum(inverse_distances[i, :]) / total_sum
                
                # Multiply the normalized heuristic measures with centrality score
                heuristic *= centrality_score
                
                heuristics[i, j] = heuristic
    
    return heuristics
```

