Code description: The proposed algorithm, called "Weighted Distance with Uncertainty, Degree, and Neighbor Count Plus Weighted Score" (WDDNCWS), builds upon Algorithm 2 by incorporating a weighted score calculation. 

The algorithm first calculates the weighted distances from the current node to each unvisited node, considering the factors of distance, uncertainty, degree, and the number of unvisited neighbors. It then calculates a weighted score for each unvisited node, further adjusting the weights based on the score. The node with the highest weighted score is selected as the next node to visit.

The incorporation of the weighted score calculation allows for more flexible and adaptive exploration of the solution space, as it assigns higher weights to the factors that are more influential in the current context.

```python
import numpy as np

def select_next_node(current_node: int, destination_node: int, unvisited_nodes: set, distance_matrix: np.ndarray) -> int:
    """
    Select the next node to visit from the unvisited nodes using the Weighted Distance with Uncertainty, Degree, Neighbor Count, and Weighted Score heuristic.
    
    Parameters
    ----------
    current_node : int
        The current node.
    destination_node : int
        The destination node to return to.
    unvisited_nodes : set
        The set of unvisited nodes.
    distance_matrix : np.ndarray
        The distance matrix of shape (n_nodes, n_nodes).
    
    Returns
    -------
    nxt_node : int
        The next node to visit.
    """
    
    n_nodes = len(distance_matrix)
    
    # Calculate the degree for each unvisited node
    degree = np.zeros(n_nodes)
    for node in unvisited_nodes:
        degree[node] = np.sum(distance_matrix[node,:] > 0)
    
    # Calculate the uncertainty scores for each unvisited node
    uncertainty_scores = np.zeros(n_nodes)
    for node in unvisited_nodes:
        variability = np.std(distance_matrix[:, node])
        uncertainty_scores[node] = variability
    
    # Calculate the number of unvisited neighbors for each unvisited node
    num_unvisited_neighbors = np.zeros(n_nodes)
    for node in unvisited_nodes:
        num_unvisited_neighbors[node] = np.sum(distance_matrix[node,:] > 0)
    
    # Calculate the weighted distances from the current node to each unvisited node, considering uncertainty, degree, and neighbor count
    weighted_distances = np.zeros(n_nodes)
    for node in unvisited_nodes:
        weighted_distance = distance_matrix[current_node, node] * degree[node] * uncertainty_scores[node] * num_unvisited_neighbors[node]
        weighted_distances[node] = weighted_distance
    
    # Calculate the weighted score for each unvisited node, adjusting the weights based on the score
    weighted_scores = np.zeros(n_nodes)
    for node in unvisited_nodes:
        distance_weight = 1.0
        uncertainty_weight = 1.0
        degree_weight = 1.0
        neighbor_weight = 1.0
        
        if distance_matrix[current_node, node] > np.max(distance_matrix) / 2:
            distance_weight = 2.0
        if uncertainty_scores[node] < np.max(uncertainty_scores) / 2:
            uncertainty_weight = 2.0
        if degree[node] < np.max(degree) / 2:
            degree_weight = 2.0
        if num_unvisited_neighbors[node] > np.max(num_unvisited_neighbors) / 2:
            neighbor_weight = 2.0
        
        weighted_score = distance_weight * weighted_distances[node] + uncertainty_weight * uncertainty_scores[node] + degree_weight * degree[node] + neighbor_weight * num_unvisited_neighbors[node]
        weighted_scores[node] = weighted_score
    
    # Select the node with the highest weighted score as the next node to visit
    nxt_node = np.argmax(weighted_scores)
    
    return nxt_node
```
