Code description: The crossover algorithm combines the ideas from both Algorithm 1 and Algorithm 2 to create a novel scoring function. This scoring function takes into account distance, demand, position, capacity, closeness to the depot, and remaining capacity factors to assign heuristic measures to edges.

```python
import numpy as np

def scoring_function(distance_matrix: np.ndarray, demands: np.ndarray, CAPACITY: int) -> np.ndarray:
    n_nodes = distance_matrix.shape[0]
    
    # Initialize heuristics matrix
    heuristics = np.zeros((n_nodes, n_nodes))
    
    # Maximum values for normalization
    max_distance = np.max(distance_matrix)
    max_demand = np.max(demands[1:])
    
    # Weight parameters for distance, demand, position, infeasibility penalty, closeness, and remaining capacity
    distance_weight = 0.4
    demand_weight = 0.2
    position_weight = 0.1
    penalty_weight = 0.05
    closeness_weight = 0.15
    capacity_weight = 0.1
    
    # Calculate normalized demands and positions
    normalized_demands = demands[1:] / max_demand
    positions = np.arange(1, n_nodes) / n_nodes
    
    max_remaining_capacity = CAPACITY - np.min(demands)
    
    for i in range(n_nodes):
        for j in range(i+1, n_nodes):
            distance = distance_matrix[i, j]
            
            # Calculate normalized distance
            normalized_distance = distance / max_distance
            
            # Check capacity constraint
            if demands[j] > CAPACITY:
                heuristics[i, j] = 0
            else:
                # Calculate penalty factor
                penalty_factor = 1 - (demands[j] / CAPACITY)
                
                # Calculate closeness factor
                closeness_factor = 1 - (distance / max_distance)
                
                # Calculate remaining capacity factor
                remaining_capacity = CAPACITY - demands[j]
                remaining_capacity_factor = remaining_capacity / max_remaining_capacity
                
                # Calculate heuristics measure
                heuristics[i, j] = (
                    distance_weight * normalized_distance +
                    demand_weight * normalized_demands[j-1] +
                    position_weight * positions[j-1] +
                    penalty_weight * penalty_factor +
                    closeness_weight * closeness_factor +
                    capacity_weight * remaining_capacity_factor
                )

    # Symmetrically set heuristics for the lower triangle of the matrix
    heuristics += np.tril(heuristics.T, -1)
    
    return heuristics
```

