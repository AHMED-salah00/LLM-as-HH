Code description: In this improved scoring function, I will combine the ideas from Algorithm 1 and Algorithm 2 to create a better scoring function. The scoring function will first calculate the inverse distances of each edge, similar to Algorithm 2. Then, instead of generating random permutations of nodes or calculating centrality measures, I will use the heuristic measures calculated in Algorithm 1. The heuristic measures will now be obtained by multiplying the inverse distances with a linear combination of the heuristic measure of the source node and the inverse number of connections of the destination node. This way, I can take into account both the distance and the number of connections of the source and destination nodes, prioritizing edges that have a close source node with many connections and a close destination node with fewer connections.

```python
import numpy as np

def scoring_function(distance_matrix: np.ndarray) -> np.ndarray:
    """
    The heuristic measures indicate how promising is each edge before actually solving this TSP instance.
    
    Parameters
    ----------
    distance_matrix : np.ndarray
        The distance matrix of shape (n_nodes, n_nodes), where diagonal elements are set to inf.
    
    Returns
    -------
    heuristics: np.ndarray
        The heuristic measures of shape (n_nodes, n_nodes) for all edges. 
    """
    n_nodes = distance_matrix.shape[0]
    
    # Calculate the inverse distances
    inverse_distances = 1 / distance_matrix
    np.fill_diagonal(inverse_distances, 0)
    
    # Initialize the heuristic measures matrix
    heuristics = np.zeros((n_nodes, n_nodes))
    
    # Calculate the heuristic measure for each edge
    for i in range(n_nodes):
        for j in range(n_nodes):
            if i != j:
                heuristics[i, j] = inverse_distances[i, j] * ((1 / (distance_matrix[i, i] * (1 + node_connections[j]))) + (inverse_distances[i, i] * (1 - (1 / node_connections[j]))))
    
    # Normalize the heuristic measures so that they sum up to 1
    heuristics /= np.sum(heuristics)
    
    return heuristics
```

We use the "inverse_distances" matrix to calculate the inverse distances of each edge, similar to Algorithm 2. Then, for each edge, we multiply the inverse distance with a linear combination of the heuristic measure of the source node (1 / distance_matrix[i, i]) and the inverse number of connections of the destination node (1 / node_connections[j]).
Finally, we normalize the heuristic measures so that they sum up to 1.
