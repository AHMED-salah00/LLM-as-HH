Code description: The proposed code aims to combine the ideas from Algorithm 1 and Algorithm 2 to create a better selecting-next-node function. This code considers the direct distance from the current node to each unvisited node, the distance from the destination node to each unvisited node, the modified greedy squeezing distance, and the degree centrality of each unvisited node. It uses a weighted sum of these factors to determine the next node to visit.

```python
import numpy as np
import networkx as nx
import random

def select_next_node(current_node: int, destination_node: int, unvisited_nodes: set, distance_matrix: np.ndarray) -> int:
    # Calculate direct distance from current node to each unvisited node
    direct_distances = distance_matrix[current_node, list(unvisited_nodes)]
    
    # Calculate distance from destination node to each unvisited node
    destination_distances = distance_matrix[destination_node, list(unvisited_nodes)]
    
    # Calculate Modified Greedy Squeezing distance for each unvisited node
    mgs_distance = {}
    for node in unvisited_nodes:
        direct_distance = distance_matrix[current_node, destination_node]
        node_distance = distance_matrix[current_node, node]
        
        # Calculate the weight based on the number of neighboring unvisited nodes
        weight = 1
        for neighbor in unvisited_nodes:
            if neighbor != node and neighbor in distance_matrix[node]:
                weight += 1

        mgs_distance[node] = direct_distance / (node_distance * weight)
    
    # Calculate degree centrality for each unvisited node
    graph = nx.from_numpy_array(distance_matrix)
    degree_centralities = nx.degree_centrality(graph)
    
    # Normalize degree centrality values
    degree_centralities = {node: degree_centralities[node] / sum(degree_centralities.values()) for node in unvisited_nodes}
    
    # Combine scores for each unvisited node
    combined_scores = 0.4 * direct_distances - 0.3 * destination_distances + 0.2 * np.array(list(mgs_distance.values())) + 0.1 * np.array([degree_centralities[node] for node in unvisited_nodes])
    
    # Find the node with the highest combined score
    nxt_node = list(unvisited_nodes)[np.argmax(combined_scores)]
    
    return nxt_node
```

