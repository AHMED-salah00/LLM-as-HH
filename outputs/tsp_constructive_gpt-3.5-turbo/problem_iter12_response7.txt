Code description: The proposed crossover algorithm aims to combine the advantages of both algorithms. It incorporates the Dynamic Score heuristic from Algorithm 2 and extends it to include the Neighbor Distance metric from Algorithm 1. The function calculates a combined score for each unvisited node, considering the distance, destination distance, Modified Greedy Squeezing distance, and Neighbor Distance. It then selects the node with the highest combined score as the next node to visit.

```python
import numpy as np

def select_next_node(current_node: int, destination_node: int, unvisited_nodes: set, distance_matrix: np.ndarray) -> int:
    # Calculate distance from current node to each unvisited node
    current_distances = distance_matrix[current_node, list(unvisited_nodes)]
    
    # Calculate distance from destination node to each unvisited node
    destination_distances = distance_matrix[destination_node, list(unvisited_nodes)]
    
    # Calculate Modified Greedy Squeezing distance for each unvisited node
    mgs_distance = {}
    for node in unvisited_nodes:
        direct_distance = distance_matrix[current_node, destination_node]
        node_distance = distance_matrix[current_node, node]
        
        # Calculate the weight based on the number of neighboring unvisited nodes
        weight = 1
        for neighbor in unvisited_nodes:
            if neighbor != node and neighbor in distance_matrix[node]:
                weight += 1

        mgs_distance[node] = direct_distance / (node_distance * weight)
        
    # Calculate Neighbor Distance for each unvisited node
    neighbor_distance = {}
    for node in unvisited_nodes:
        neighbor_distances = distance_matrix[node, list(unvisited_nodes - set([node]))]
        neighbor_distance[node] = np.mean(neighbor_distances)
        
    # Calculate combined scores for each unvisited node
    combined_scores = 0.5 * current_distances + 0.3 * destination_distances + 0.4 * np.array(list(mgs_distance.values())) + 0.2 * np.array(list(neighbor_distance.values()))
    
    # Find the node with the highest combined score
    nxt_node = list(unvisited_nodes)[np.argmax(combined_scores)]
    
    return nxt_node
```

The code combines the distance-based selection of Algorithm 1 and the Neighbor Distance metric of Algorithm 2 to select the next node. It calculates the distance from the current node to each unvisited node, as well as the distance from the destination node to each unvisited node. It also calculates the Modified Greedy Squeezing distance and Neighbor Distance for each unvisited node. The code then combines these metrics using weights of 0.5, 0.3, 0.4, and 0.2, respectively. Finally, it selects the unvisited node with the highest combined score as the next node to visit.
