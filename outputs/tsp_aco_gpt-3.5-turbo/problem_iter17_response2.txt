Code description: In this improved scoring function, I will combine the ideas from Algorithm 1 and Algorithm 2 by considering the inverse distance, edge importance, and node centrality measures. The scoring function will calculate the inverse distance matrix as in Algorithm 1 to capture the distance information. Additionally, I will compute the edge importance measure by taking the average of the node degrees of the source and destination nodes, similar to Algorithm 1. To incorporate node centrality measures, I will compute both degree centrality and closeness centrality. The degree centrality measures the number of edges connected to each node, while the closeness centrality measures the average distance from a node to all other nodes. By combining these centrality measures, I can capture the importance of each node in the graph. Finally, I will combine the inverse distance, edge importance, and node centrality measures to calculate the heuristic measures for each edge.

```python
import numpy as np
import networkx as nx
from scipy.sparse import csgraph

def scoring_function(distance_matrix: np.ndarray) -> np.ndarray:
    """
    The heuristic measures indicate how promising is each edge before actually solving this TSP instance.

    Parameters
    ----------
    distance_matrix : np.ndarray
        The distance matrix of shape (n_nodes, n_nodes), where diagonal elements are set to inf.

    Returns
    -------
    heuristics: np.ndarray
        The heuristic measures of shape (n_nodes, n_nodes) for all edges. 
    """
    n_nodes = distance_matrix.shape[0]
    
    # Compute the inverse distances
    inverse_distances = 1 / distance_matrix
    np.fill_diagonal(inverse_distances, 0)
    
    # Compute the node degrees
    node_degrees = np.sum(distance_matrix != np.inf, axis=1) - 1
    
    # Compute the node centrality measures
    graph = nx.Graph(distance_matrix)
    degree_centrality = np.array(list(nx.degree_centrality(graph).values()))
    closeness_centrality = csgraph.shortest_path(distance_matrix, directed=False)
    closeness_centrality = 1 / np.average(closeness_centrality, axis=1)
    
    # Compute the edge importance measure
    edge_importance = (node_degrees[:, np.newaxis] + node_degrees) / (2 * np.max(node_degrees))
    
    # Calculate the heuristic measures
    heuristics = inverse_distances * edge_importance * (degree_centrality[:, np.newaxis] * closeness_centrality)
    heuristics /= np.sum(heuristics)
    
    return heuristics
```
