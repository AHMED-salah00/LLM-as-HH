Code description: In this improved scoring function, I will integrate another factor - the load balance of each vehicle - to consider the capacity constraint. This factor will assign higher heuristic measures to edges that help maintain a more balanced load among vehicles.

```python
import numpy as np
from sklearn.cluster import KMeans

def scoring_function(distance_matrix: np.ndarray, demands: np.ndarray, CAPACITY: int) -> np.ndarray:
    n_nodes = distance_matrix.shape[0]
    
    max_distance = np.max(distance_matrix)
    max_demand = np.max(demands[1:])
    
    heuristics = np.zeros((n_nodes, n_nodes))
    
    distance_weight = 0.4
    demand_weight = 0.2
    clustering_weight = 0.2
    load_balance_weight = 0.2
    
    # Calculate clustering factor
    kmeans = KMeans(n_clusters=3)
    cluster_labels = kmeans.fit_predict(distance_matrix[1:, 1:])
    
    cluster_distances = np.zeros((n_nodes, n_nodes))
    for i in range(1, n_nodes):
        for j in range(i + 1, n_nodes):
            if cluster_labels[i-1] == cluster_labels[j-1]:
                cluster_distances[i, j] = distance_matrix[i, j]
                cluster_distances[j, i] = distance_matrix[j, i]
            else:
                cluster_distances[i, j] = max_distance
                cluster_distances[j, i] = max_distance
    
    # Calculate demand ratio and load balance factor
    demand_ratio = demands[1:] / CAPACITY
    load_balance_factors = np.abs(np.cumsum(demands[1:]) - np.sum(demands[1:])) / np.sum(demands[1:])
    
    # Calculate heuristic measures
    for i in range(1, n_nodes):
        for j in range(i + 1, n_nodes):
            distance = distance_matrix[i, j]
            demand_ratio_j = demand_ratio[j-1]
            cluster_distance = cluster_distances[i, j]
            load_balance_factor = load_balance_factors[j-1]
            
            normalized_distance = distance / max_distance
            normalized_demand_ratio = demand_ratio_j / max_demand
            normalized_position = (j - 1) / (n_nodes - 1)
            
            inverted_distance = 1 / distance
            clustering_factor = np.exp(-cluster_distance / max_distance)
            
            heuristic_distance = distance_weight * inverted_distance
            heuristic_demand = demand_weight * normalized_demand_ratio
            heuristic_position = clustering_weight * clustering_factor
            heuristic_load_balance = load_balance_weight * (1 - load_balance_factor)
            
            heuristics[i, j] = heuristic_distance + heuristic_demand + heuristic_position + heuristic_load_balance
            heuristics[j, i] = heuristics[i, j]
    
    return heuristics
```
