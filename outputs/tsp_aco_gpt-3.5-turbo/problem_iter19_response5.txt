Code description: In this improved scoring function, I will combine elements from both Algorithm 1 and Algorithm 2 to create a better heuristic measure. The scoring function will calculate the inverse distances as in Algorithm 2, and also consider the edge attractiveness from Algorithm 1. To calculate the heuristic measures, I will multiply the inverse distance with the square root of the edge attractiveness. Additionally, I will multiply the result with the square root of the average of the source and destination node degrees to incorporate edge importance. This way, the scoring function will give higher heuristic measures to edges with shorter distances, higher attractiveness, and higher node degrees. I will also normalize the heuristic measures so that they sum up to 1.

```python
import numpy as np

def scoring_function(distance_matrix: np.ndarray) -> np.ndarray:
    """
    The heuristic measures indicate how promising is each edge before actually solving this TSP instance.
    
    Parameters
    ----------
    distance_matrix : np.ndarray
        The distance matrix of shape (n_nodes, n_nodes), where diagonal elements are set to inf.
    
    Returns
    -------
    heuristics: np.ndarray
        The heuristic measures of shape (n_nodes, n_nodes) for all edges. 
    """
    n_nodes = distance_matrix.shape[0]
    
    # Initialize the heuristic measures matrix
    heuristics = np.zeros((n_nodes, n_nodes))
    
    # Compute the inverse distances
    inverse_distances = 1 / distance_matrix
    np.fill_diagonal(inverse_distances, 0)
    
    # Compute the edge attractiveness
    edge_attractiveness = np.zeros((n_nodes, n_nodes))
    for i in range(n_nodes):
        for j in range(n_nodes):
            if i != j:
                edge_attractiveness[i, j] = 1 / distance_matrix[i, j] * (1 + np.count_nonzero(distance_matrix[j]))
    
    # Calculate the edge importance measure
    edge_importance = np.sqrt(node_degrees[:, np.newaxis] * node_degrees) / np.max(node_degrees)
    
    # Calculate the heuristic measure for each edge
    for i in range(n_nodes):
        for j in range(n_nodes):
            if i != j:
                heuristics[i, j] = inverse_distances[i, j] * np.sqrt(edge_attractiveness[i, j]) * np.sqrt((node_degrees[i] + node_degrees[j]) / (2 * np.max(node_degrees)))
    
    # Normalize the heuristic measures so that they sum up to 1
    heuristics /= np.sum(heuristics)
    
    return heuristics
```
