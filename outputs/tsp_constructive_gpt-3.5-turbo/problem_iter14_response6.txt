Code description: In this code, I propose a novel selecting-next-node function called "Weighted Exploration". This heuristic takes into account both the distance from the current node to each unvisited node and the distance from the destination node to each unvisited node. It dynamically adjusts the weights based on the progress made towards the destination node to balance exploration and exploitation.

```python
import numpy as np

def select_next_node(current_node: int, destination_node: int, unvisited_nodes: set, distance_matrix: np.ndarray) -> int:
    # Calculate distance from current node to each unvisited node
    current_distances = distance_matrix[current_node, list(unvisited_nodes)]
    
    # Calculate distance from destination node to each unvisited node
    destination_distances = distance_matrix[destination_node, list(unvisited_nodes)]

    # Calculate progress towards the destination node
    progress = 1 - (current_distances / (current_distances + destination_distances))
    
    # Update the weights based on the progress
    exploration_weight = 0.8 * progress
    exploitation_weight = 0.2 * (1 - progress)
    
    # Calculate the weighted sum of the distances to select the next node
    weighted_distances = exploration_weight * current_distances + exploitation_weight * destination_distances
    
    # Find the node with the smallest weighted distance
    nxt_node = list(unvisited_nodes)[np.argmin(weighted_distances)]
    
    return nxt_node
```

This new algorithm calculates the progress towards the destination node using the current distances and destination distances. The progress value determines the weights for exploration and exploitation. as the progress increases, the exploration weight increases while the exploitation weight decreases, thus balancing the exploration and exploitation. The algorithm selects the next node based on the weighted sum of the distances, giving higher weight to the exploration component.
