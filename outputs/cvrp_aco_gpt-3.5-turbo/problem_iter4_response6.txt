Code description: My novel scoring function aims to combine the best features of Algorithm 1 and Algorithm 2 to create a more effective scoring function. It considers the distance, demand, and position of each node to assign heuristic measures to each edge. The weights assigned to distance, demand, and position can be customized to adjust their importance. In addition, it incorporates the capacity constraint by penalizing edges that exceed the vehicle capacity.

The modified algorithm initializes an empty array for the heuristic measures. It then iterates over all pairs of nodes (i, j) and calculates the heuristic measure for the edge connecting these nodes. For each edge, the heuristic measure is calculated as follows:

- If the edge connects the depot (node 0) to a customer node (i > 0), the heuristic measure is set to a weighted sum of the normalized demand of the customer node, the ratio of the normalized demand to the distance, and the position of the customer node. The weights control the importance of each factor.

- If the edge connects two customer nodes (i > 0 and j > 0), the heuristic measure is set to a weighted sum of the normalized sum of the demands of the two nodes, the ratio of the normalized sum of the demands to the distance, and the position of the second customer node. The weights control the importance of each factor.

Additionally, the modified algorithm introduces a capacity penalty factor for edges that exceed the vehicle capacity. If the demand sum of the two nodes exceeds the vehicle capacity, the heuristic measure is multiplied by a penalty factor to reduce its importance.

The resulting heuristic measures are returned as an array.

```python
import numpy as np

def scoring_function(distance_matrix: np.ndarray, demands: np.ndarray, CAPACITY: int) -> np.ndarray:
    n_nodes = distance_matrix.shape[0]
    
    max_distance = np.max(distance_matrix)
    max_demand = np.max(demands[1:])
    
    heuristics = np.zeros((n_nodes, n_nodes))
    
    for i in range(n_nodes):
        for j in range(n_nodes):
            if i != j:
                demand_sum = demands[i] + demands[j]
                distance = distance_matrix[i, j]
                
                if i == 0:
                    normalized_demand = demands[j] / max_demand
                    position = j / (n_nodes - 1)
                    
                    weight_distance = 0.4
                    weight_demand = 0.4
                    weight_position = 0.2
                    
                    heuristic_demand = normalized_demand / distance * weight_demand
                    heuristic_distance = weight_distance / distance
                    heuristic_position = weight_position * position
                    
                    heuristics[i, j] = heuristic_distance + heuristic_demand + heuristic_position
                elif j == 0:
                    normalized_demand = demands[i] / max_demand
                    position = i / (n_nodes - 1)
                    
                    weight_distance = 0.4
                    weight_demand = 0.4
                    weight_position = 0.2
                    
                    heuristic_demand = normalized_demand / distance * weight_demand
                    heuristic_distance = weight_distance / distance
                    heuristic_position = weight_position * position
                    
                    heuristics[i, j] = heuristic_distance + heuristic_demand + heuristic_position
                else:
                    normalized_demand_sum = demand_sum / max_demand
                    position = j / (n_nodes - 1)
                    
                    weight_distance = 0.3
                    weight_demand = 0.3
                    weight_position = 0.2
                    weight_capacity_penalty = 0.2
                    
                    heuristic_demand = normalized_demand_sum / distance * weight_demand
                    heuristic_distance = weight_distance / distance
                    heuristic_position = weight_position * position
                    
                    if demand_sum > CAPACITY:
                        capacity_penalty = CAPACITY / demand_sum
                        heuristic_capacity_penalty = weight_capacity_penalty * capacity_penalty
                        heuristics[i, j] = (heuristic_distance + heuristic_demand + heuristic_position) * heuristic_capacity_penalty
                    else:
                        heuristics[i, j] = heuristic_distance + heuristic_demand + heuristic_position
    
    return heuristics
```

This modified scoring function combines the factors of demand, distance, position, and capacity to assign heuristic measures to each edge. The weights for each factor can be adjusted to customize their importance.
