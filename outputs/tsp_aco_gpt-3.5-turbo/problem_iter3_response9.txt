Code description: In this improved scoring function, I will combine the features of both Algorithm 1 and Algorithm 2, while making some modifications to improve the effectiveness of the heuristics. The modified algorithm will have the following features:

1. Degree of nodes: Nodes with higher degrees indicate higher connectivity and importance. We will incorporate this information by including a term proportional to the inverse of the degree of the destination node.

2. Hop count between nodes: It represents the shortest number of edges that must be traversed to go from one node to another. Lower hop counts indicate easier accessibility between nodes and will be accounted for in the heuristic measures.

3. Centrality score: Centrality measures the importance or influence of a node in the network. We will calculate the centrality score by finding the sum of distances to other nodes.

4. Normalization: To ensure that the scoring function outputs values that sum up to 1, we will divide each heuristic measure by the sum of all heuristic measures.

5. Modification to the hop count calculation: The hop count calculation in Algorithm 1 is a brute force approach that checks for all possible hop counts. To make it more efficient, I will use networkx library to calculate the shortest path lengths between nodes and use that to compute the hop count between nodes.

```python
import numpy as np
import networkx as nx

def scoring_function(distance_matrix: np.ndarray) -> np.ndarray:
    """
    The heuristic measures indicate how promising is each edge before actually solving this TSP instance.
    
    Parameters
    ----------
    distance_matrix : np.ndarray
        The distance matrix of shape (n_nodes, n_nodes), where diagonal elements are set to inf.
    
    Returns
    -------
    heuristics: np.ndarray
        The heuristic measures of shape (n_nodes, n_nodes) for all edges. 
    """
    
    n_nodes = distance_matrix.shape[0]
    
    # Compute the inverse of the distance matrix
    inverse_distance_matrix = np.where(distance_matrix != 0, 1 / distance_matrix, 0)
    
    # Compute the degree of each node
    node_degrees = np.count_nonzero(distance_matrix, axis=1)
    
    # Compute the hop count between nodes
    hop_count = np.zeros((n_nodes, n_nodes), dtype=int)
    
    # Construct the graph using distance matrix
    graph = nx.from_numpy_matrix(distance_matrix, create_using=nx.Graph)
    
    # Calculate shortest path lengths using networkx library
    path_lengths = dict(nx.all_pairs_shortest_path_length(graph))
    
    # Compute the hop count
    for i in range(n_nodes):
        for j in range(n_nodes):
            hop_count[i, j] = path_lengths[i][j]
    
    # Compute the sum of distances to other nodes for each node
    node_scores = np.sum(inverse_distance_matrix, axis=1)
    
    # Compute the heuristic measures
    heuristics = (inverse_distance_matrix * (1 / node_degrees[:, np.newaxis]) * hop_count) / np.sum(inverse_distance_matrix)
    
    return heuristics
```
