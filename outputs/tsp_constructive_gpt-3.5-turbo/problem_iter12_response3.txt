Code description: The proposed algorithm, called "Improved Weighted Expected Improvement with Local Search", builds upon the Weighted Expected Improvement with Local Search algorithm, but improves the calculation of expected improvements by incorporating both local and global information. In addition to considering the weighted distance, uncertainty score, and degree of the neighboring nodes, this algorithm also takes into account the average distance between all unvisited nodes and their close neighbors.

```python
import numpy as np

def select_next_node(current_node: int, destination_node: int, unvisited_nodes: set, distance_matrix: np.ndarray) -> int:
    """
    Select the next node to visit using the Improved Weighted Expected Improvement with Local Search heuristic.
    
    Parameters
    ----------
    current_node : int
        The current node.
    destination_node : int
        The destination node to return to.
    unvisited_nodes : set
        The set of unvisited nodes.
    distance_matrix : np.ndarray
        The distance matrix of shape (n_nodes, n_nodes).
    
    Returns
    -------
    nxt_node : int
        The next node to visit.
    """
    n_nodes = len(distance_matrix)
    
    # Calculate the degree for each unvisited node
    degree = np.zeros(n_nodes)
    for node in unvisited_nodes:
        degree[node] = np.sum(distance_matrix[node,:] > 0)
    
    # Calculate the uncertainty scores for each unvisited node
    uncertainty_scores = np.zeros(n_nodes)
    for node in unvisited_nodes:
        variability = np.std(distance_matrix[:, node])
        uncertainty_scores[node] = variability
    
    # Calculate the expected improvements for each unvisited node, considering weighted distance, uncertainty score, degree,
    # and average distance to close neighbors
    expected_improvements = np.zeros(n_nodes)
    for node in unvisited_nodes:
        expected_improvement = 0
        
        # Calculate the weighted distance from the current node to the unvisited node
        weighted_distance = distance_matrix[current_node, node] * degree[node] * uncertainty_scores[node]
        
        # Explore the neighborhood of the current node
        neighboring_nodes = set()
        for neighbor in unvisited_nodes:
            if distance_matrix[current_node, neighbor] > 0:
                neighboring_nodes.add(neighbor)
        
        # Calculate the weighted distance from the neighboring nodes to the unvisited node
        for neighbor in neighboring_nodes:
            weighted_distance_neighbor = distance_matrix[neighbor, node] * degree[node] * uncertainty_scores[node]
            weighted_distance += weighted_distance_neighbor
        
        # Calculate the average distance between all unvisited nodes and their close neighbors
        avg_distance = 0
        for unvisited in unvisited_nodes:
            if unvisited != node:
                avg_distance += np.mean(distance_matrix[unvisited, list(neighboring_nodes)])
        avg_distance /= len(unvisited_nodes) - 1
        
        # Incorporate the average distance into the expected improvement calculation
        expected_improvement = weighted_distance / len(neighboring_nodes) * avg_distance
        expected_improvements[node] = expected_improvement
    
    # Select the node with the highest expected improvement as the next node to visit
    nxt_node = np.argmax(expected_improvements)
    
    return nxt_node
```
