Code description: 

This code aims to improve the scoring_function by considering the degree of each node, the total centrality of each node based on inverse distances, and the edge importance measure. The edge importance measure is calculated by considering the importance of the endpoints and normalizing it. 

Improvements:
1. Remove the normalization step for the edge importance measure as it is already being normalized.
2. Change the calculation of the edge importance measure to consider the importance of both endpoints by adding the inverse degrees of the endpoints.
3. Multiply the inverse distances by the node degrees to give more weight to edges connecting high degree nodes.
4. Add a constraint that sets the heuristic measure to zero if the distance between two nodes is infinity.

```python
import numpy as np

def scoring_function(distance_matrix: np.ndarray) -> np.ndarray:
    """
    The heuristic measures indicate how promising is each edge before actually solving this TSP instance.

    Parameters
    ----------
    distance_matrix : np.ndarray
        The distance matrix of shape (n_nodes, n_nodes), where diagonal elements are set to inf.

    Returns
    -------
    heuristics: np.ndarray
        The heuristic measures of shape (n_nodes, n_nodes) for all edges. 
    """
    n_nodes = distance_matrix.shape[0]
    
    # Calculate the inverse distances
    inverse_distances = 1 / distance_matrix
    np.fill_diagonal(inverse_distances, 0)
    
    # Compute the degree of each node
    node_degrees = np.sum(distance_matrix != np.inf, axis=1)
    
    # Compute the total centrality of each node
    total_centrality = np.sum(inverse_distances, axis=1) / np.sum(inverse_distances)
    
    # Compute the edge importance measure
    edge_importance = node_degrees[:, np.newaxis] + node_degrees + inverse_distances
    
    # Set edge importance measure to zero if distance is infinity
    edge_importance[distance_matrix == np.inf] = 0
    
    # Multiply inverse distances by node degrees
    inverse_distances *= node_degrees[:, np.newaxis]
    
    # Calculate the heuristic measures
    heuristics = edge_importance * inverse_distances * total_centrality[:, np.newaxis]
    
    return heuristics
```

