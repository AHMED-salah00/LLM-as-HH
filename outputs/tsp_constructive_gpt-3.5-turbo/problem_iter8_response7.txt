Code description: The following code implements a novel selecting-next-node function for the Traveling Salesman Problem (TSP) using a combination of local and global information. The function selects the next node based on both the local distance between the current node and the unvisited nodes, and the global distance between all unvisited nodes. The function considers the close neighbors of the current node and selects the unvisited node that has the smallest average distance to those neighbors.

```python
import numpy as np

def select_next_node(current_node: int, destination_node: int, unvisited_nodes: set, distance_matrix: np.ndarray) -> int:
    """
    Select the next node to visit from the unvisited nodes using a combination of local and global information.
    
    Parameters
    ----------
    current_node : int
        The current node.
    destination_node : int
        The destination node to return to.
    unvisited_nodes : set
        The set of unvisited nodes.
    distance_matrix : np.ndarray
        The distance matrix of shape (n_nodes, n_nodes).
    
    Returns
    -------
    nxt_node : int
        The next node to visit.
    """
    
    # Initialize variables
    min_avg_distance = np.inf
    best_node = None
    
    # Calculate the average distance between the current_node and its neighbors
    neighbors = [node for node in unvisited_nodes if distance_matrix[current_node, node] < np.inf]
    avg_distance = np.mean([distance_matrix[current_node, node] for node in neighbors])
    
    # Iterate over unvisited nodes
    for node in unvisited_nodes:
        if node != current_node:
            # Calculate the average distance between the neighbors and the current unvisited node
            avg_distance_new = np.mean([distance_matrix[node, neigh] for neigh in neighbors])
            
            # Update the best_node if the average distance is smaller
            if avg_distance_new < min_avg_distance:
                min_avg_distance = avg_distance_new
                best_node = node
    
    nxt_node = best_node
    return nxt_node
```

-----
Code description: 

The modified code below uses the local information to find the next node, but it also includes a random element. It sorts all the unvisited nodes in ascending order of their distances to the current node and then selects the next node randomly from the top k closest nodes. This introduces some randomness into the selection process, which can help avoid getting stuck in local optima.

```python
import numpy as np
import random

def select_next_node(current_node: int, destination_node: int, unvisited_nodes: set, distance_matrix: np.ndarray) -> int:
    """
    Select the next node to visit from the unvisited nodes using a combination of local and global information.
    
    Parameters
    ----------
    current_node : int
        The current node.
    destination_node : int
        The destination node to return to.
    unvisited_nodes : set
        The set of unvisited nodes.
    distance_matrix : np.ndarray
        The distance matrix of shape (n_nodes, n_nodes).
    
    Returns
    -------
    nxt_node : int
        The next node to visit.
    """
    
    # Initialize variables
    k = 5  # Number of closest nodes to consider
    closest_nodes = []
    
    # Calculate the distances between the current_node and all unvisited nodes
    distances = {node: distance_matrix[current_node, node] for node in unvisited_nodes if node != current_node}
    
    # Sort the unvisited nodes based on their distances to the current_node
    sorted_nodes = sorted(distances, key=distances.get)
    
    # Select randomly from the top k closest nodes
    if len(sorted_nodes) > k:
        closest_nodes = sorted_nodes[:k]
    elif len(sorted_nodes) > 0:
        closest_nodes = sorted_nodes
    
    # Randomly select a node from the closest_nodes
    nxt_node = random.choice(closest_nodes) if closest_nodes else None
    
    return nxt_node
```
