Code description: The proposed scoring function aims to improve the previous algorithms by considering both the degree centrality and the closeness centrality of each node. The degree centrality measures the number of edges connected to each node, while the closeness centrality measures the average distance from a node to all other nodes. By combining these two centrality measures, we can obtain a more comprehensive evaluation of each edge's potential usefulness in the TSP instance.

```python
import numpy as np
from scipy.sparse import csgraph

def scoring_function(distance_matrix: np.ndarray) -> np.ndarray:
    """
    The heuristic measures indicate how promising is each edge before actually solving this TSP instance.

    Parameters
    ----------
    distance_matrix : np.ndarray
        The distance matrix of shape (n_nodes, n_nodes), where diagonal elements are set to inf.

    Returns
    -------
    heuristics: np.ndarray
        The heuristic measures of shape (n_nodes, n_nodes) for all edges. 
    """
    n_nodes = distance_matrix.shape[0]
    
    # Compute the degree centrality of each node
    degree_centrality = np.sum(distance_matrix != np.inf, axis=1) / (n_nodes - 1)
    
    # Compute the closeness centrality of each node
    closeness_centrality = csgraph.shortest_path(distance_matrix, directed=False)
    closeness_centrality = 1 / np.average(closeness_centrality, axis=1)
    
    # Combine the degree and closeness centrality measures
    combined_centrality = degree_centrality[:, np.newaxis] * closeness_centrality
    
    # Calculate the heuristic measures
    heuristics = combined_centrality / np.sum(combined_centrality)
    
    return heuristics
```

Note: In this code, we utilize the `scipy.sparse.csgraph.shortest_path` function to compute the closeness centrality matrix efficiently. This function calculates the shortest path distances between all pairs of nodes using the Floyd-Warshall algorithm.
