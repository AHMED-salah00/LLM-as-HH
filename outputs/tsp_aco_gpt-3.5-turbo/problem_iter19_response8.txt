Code description: In this modified scoring function, I will calculate the inverse distances of each edge as in the previous algorithm. Additionally, I will calculate the average distance of each node to other nodes and use it as a measure of node centrality. The heuristic measure for each edge will be obtained by multiplying the inverse distance with the node centrality of the destination node. Finally, the heuristic measures will be normalized to ensure they sum up to 1.

```python
import numpy as np
import networkx as nx

def scoring_function(distance_matrix: np.ndarray) -> np.ndarray:
    """
    The heuristic measures indicate how promising is each edge before actually solving this TSP instance.

    Parameters
    ----------
    distance_matrix : np.ndarray
        The distance matrix of shape (n_nodes, n_nodes), where diagonal elements are set to inf.

    Returns
    -------
    heuristics: np.ndarray
        The heuristic measures of shape (n_nodes, n_nodes) for all edges. 
    """
    n_nodes = distance_matrix.shape[0]

    # Calculate the inverse distances
    inverse_distances = 1 / distance_matrix
    np.fill_diagonal(inverse_distances, 0)

    # Compute the average distance of each node to other nodes
    node_centralities = np.mean(inverse_distances, axis=1)

    # Initialize the heuristic measures matrix
    heuristics = np.zeros((n_nodes, n_nodes))

    # Calculate the heuristic measure for each edge
    for i in range(n_nodes):
        for j in range(n_nodes):
            if i != j:
                heuristics[i, j] = inverse_distances[i, j] * node_centralities[j]

    # Normalize the heuristic measures so that they sum up to 1
    heuristics /= np.sum(heuristics)

    return heuristics
```

