Code description: In this improved scoring function, I will calculate the heuristic measures for each edge based on both the shortest path lengths and the node degrees. Instead of using a single measure like in Algorithm 2, I will combine these measures using a weighted average. 

To calculate the shortest path lengths, I will use the Floyd-Warshall algorithm. Then, I will compute the node degrees by counting the number of non-zero elements in each row of the distance matrix.

The heuristic measure for each edge will be the weighted average of the inverse shortest path length and the inverse node degree. The weights can be adjusted to prioritize one measure over the other.

Finally, I will normalize the heuristic measures so that they sum up to 1.

```python
import numpy as np


def scoring_function(distance_matrix: np.ndarray) -> np.ndarray:
    """
    The heuristic measures indicate how promising is each edge before actually solving this TSP instance.

    Parameters
    ----------
    distance_matrix : np.ndarray
        The distance matrix of shape (n_nodes, n_nodes), where diagonal elements are set to inf.

    Returns
    -------
    heuristics: np.ndarray
        The heuristic measures of shape (n_nodes, n_nodes) for all edges.
    """

    n_nodes = distance_matrix.shape[0]

    # Compute the shortest path lengths between all nodes using Floyd-Warshall algorithm
    shortest_paths = np.copy(distance_matrix)
    for k in range(n_nodes):
        for i in range(n_nodes):
            for j in range(n_nodes):
                shortest_paths[i, j] = min(shortest_paths[i, j], shortest_paths[i, k] + shortest_paths[k, j])

    # Compute the node degrees
    node_degrees = np.count_nonzero(distance_matrix, axis=1)

    # Calculate the heuristic measures
    heuristics = np.zeros((n_nodes, n_nodes))
    for i in range(n_nodes):
        for j in range(n_nodes):
            if i != j:
                # Calculate the weights for the average
                shortest_path_weight = 0.5  # Weight for shortest path length measure
                node_degree_weight = 0.5  # Weight for node degree measure
                
                # Combine shortest path lengths and node degrees using a weighted average
                shortest_path_measure = 1 / shortest_paths[i, j]
                node_degree_measure = 1 / node_degrees[i]
                heuristic_measure = (
                    shortest_path_weight * shortest_path_measure 
                    + node_degree_weight * node_degree_measure
                )
                heuristics[i, j] = heuristic_measure

    # Normalize the heuristic measures so that they sum up to 1
    heuristics /= np.sum(heuristics)

    return heuristics
```

