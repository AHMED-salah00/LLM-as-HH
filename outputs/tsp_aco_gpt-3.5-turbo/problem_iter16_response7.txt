Code description: The proposed scoring function aims to combine the best aspects of Algorithm 1 and Algorithm 2 to create an enhanced scoring function. It incorporates node centrality measures from Algorithm 1 and penalizes edges based on a modified distance ratio similar to Algorithm 2. The modified distance calculation takes into account both the average distance and the difference between the current distance and the average distance. This allows for a better evaluation of edges based on their relative position in the TSP instance, considering both the centrality of the nodes and their distance to the average.

```python
import numpy as np

def scoring_function(distance_matrix: np.ndarray) -> np.ndarray:
    """
    The heuristic measures indicate how promising is each edge before actually solving this TSP instance.
    
    Parameters
    ----------
    distance_matrix : np.ndarray
        The distance matrix of shape (n_nodes, n_nodes), where diagonal elements are set to inf.
    
    Returns
    -------
    heuristics: np.ndarray
        The heuristic measures of shape (n_nodes, n_nodes) for all edges. 
    """
    n_nodes = distance_matrix.shape[0]
    
    # Initialize the heuristic measures matrix
    heuristics = np.zeros((n_nodes, n_nodes))
    
    # Compute the inverse of the distance matrix
    inverse_distance_matrix = np.where(distance_matrix != 0, 1 / distance_matrix, 0)
    
    # Compute the degree centrality of each node
    degree_centrality = np.sum(inverse_distance_matrix, axis=1) / (n_nodes - 1)
    
    # Compute the total centrality of each node
    total_centrality = np.sum(inverse_distance_matrix, axis=1) / np.sum(inverse_distance_matrix)
    
    # Calculate the average distance in the distance matrix
    average_distance = np.mean(distance_matrix[distance_matrix != np.inf])
    
    # Calculate the heuristic measure for each edge
    for i in range(n_nodes):
        for j in range(n_nodes):
            if i != j:
                distance_ratio = abs(distance_matrix[i, j] - average_distance) / average_distance
                edge_importance = (degree_centrality[i] + degree_centrality[j]) / 2
                heuristics[i, j] = distance_ratio * edge_importance
    
    # Normalize the heuristic measures so that they sum up to 1
    heuristics /= np.sum(heuristics)
    
    return heuristics
```

