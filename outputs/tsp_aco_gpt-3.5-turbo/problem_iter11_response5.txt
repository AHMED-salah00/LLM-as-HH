Code description: The crossover scoring function combines the inverse distances calculation from Algorithm 2 with the heuristic measures calculation from Algorithm 1. It calculates the inverse distances of each edge as the inverse of the distance matrix. Then, it calculates the number of connections for each node and computes the heuristic measures using the inverse distances and the number of connections. Finally, it normalizes the heuristic measures so that they sum up to 1.

```python
import numpy as np

def scoring_function(distance_matrix: np.ndarray) -> np.ndarray:
    """
    The heuristic measures indicate how promising is each edge before actually solving this TSP instance.
    
    Parameters
    ----------
    distance_matrix : np.ndarray
        The distance matrix of shape (n_nodes, n_nodes), where diagonal elements are set to inf.
    
    Returns
    -------
    heuristics: np.ndarray
        The heuristic measures of shape (n_nodes, n_nodes) for all edges. 
    """
    n_nodes = distance_matrix.shape[0]
    
    # Calculate the inverse distances
    inverse_distances = 1 / distance_matrix
    np.fill_diagonal(inverse_distances, 0)
    
    # Compute the degree of each node
    node_degrees = np.sum(distance_matrix != np.inf, axis=1)
    
    # Initialize the heuristic measures matrix
    heuristics = np.zeros((n_nodes, n_nodes))
    
    # Calculate the heuristic measure for each edge
    for i in range(n_nodes):
        for j in range(n_nodes):
            if i != j:
                heuristics[i, j] = inverse_distances[i, j] * (inverse_distances[i, j] / (1 + node_degrees[j]))
    
    # Normalize the heuristic measures so that they sum up to 1
    heuristics /= np.sum(heuristics)
    
    return heuristics
```

