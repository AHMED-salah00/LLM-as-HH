Code description: The proposed algorithm, called "Iterative Uncertainty-based Weighted Distance and Degree Plus Degree Ratio Plus Iterative Degree Ratio" (IUWDDDRI), builds upon the IUWDDDR algorithm by incorporating an additional factor of iterative degree ratio. 

The algorithm first calculates the degree ratio for each node. It then calculates an iterative degree ratio for each unvisited node by considering the degree ratios of its neighbors iteratively. The iterative degree ratio is calculated by taking the average of the degree ratios of the current node and its neighbors, and repeating this process for several iterations. 

Next, the algorithm calculates the iterative uncertainty scores for each unvisited node using the same method as the IUWDDDR algorithm. It then calculates the weighted distances from the current node to each unvisited node, considering the factors of distance, uncertainty, degree, degree ratio, iterative uncertainty, and iterative degree ratio. It then calculates a weighted score for each unvisited node, further adjusting the weights based on the score. The node with the highest weighted score is selected as the next node to visit.

The incorporation of the iterative degree ratio factor allows for a more comprehensive evaluation of the nodes, taking into account their connectivity and the degree ratios of the surrounding nodes.

```python
import numpy as np

def select_next_node(current_node: int, destination_node: int, unvisited_nodes: set, distance_matrix: np.ndarray) -> int:
    """
    Select the next node to visit from the unvisited nodes using the IUWDDDRI heuristic.
    
    Parameters
    ----------
    current_node : int
        The current node.
    destination_node : int
        The destination node to return to.
    unvisited_nodes : set
        The set of unvisited nodes.
    distance_matrix : np.ndarray
        The distance matrix of shape (n_nodes, n_nodes).
    
    Returns
    -------
    nxt_node : int
        The next node to visit.
    """
    
    n_nodes = len(distance_matrix)
    
    # Calculate the degree ratio for each node
    degree_ratio = np.zeros(n_nodes)
    for node in range(n_nodes):
        degree = np.sum(distance_matrix[node,:] > 0)
        degree_ratio[node] = degree / (n_nodes - 1)
    
    # Calculate the iterative degree ratio for each unvisited node
    num_iterations = 5
    iterative_degree_ratio = degree_ratio.copy()
    
    for iteration in range(num_iterations):
        for node in unvisited_nodes:
            neighbor_degree_ratios = degree_ratio[list(distance_matrix[node,:] > 0) and list(unvisited_nodes)]
            iterative_degree_ratio[node] = np.mean(neighbor_degree_ratios)
    
    # Calculate the iterative uncertainty scores for each unvisited node
    uncertainty_scores = np.zeros(n_nodes)
    for iteration in range(num_iterations):
        for node in unvisited_nodes:
            neighbor_uncertainty_scores = uncertainty_scores[list(distance_matrix[node,:] > 0) and list(unvisited_nodes)]
            uncertainty_scores[node] = np.mean(neighbor_uncertainty_scores)
    
    # Calculate the weighted distances from the current node to each unvisited node, considering distance, uncertainty, degree, degree ratio, iterative uncertainty, and iterative degree ratio
    weighted_distances = np.zeros(n_nodes)
    for node in unvisited_nodes:
        weighted_distance = distance_matrix[current_node, node] * degree[node] * degree_ratio[node] * uncertainty_scores[node] * iterative_degree_ratio[node]
        weighted_distances[node] = weighted_distance
    
    # Calculate the weighted score for each unvisited node, adjusting the weights based on the score
    weighted_scores = np.zeros(n_nodes)
    for node in unvisited_nodes:
        distance_weight = 1.0
        uncertainty_weight = 1.0
        degree_weight = 1.0
        degree_ratio_weight = 1.0
        iterative_uncertainty_weight = 1.0
        iterative_degree_ratio_weight = 1.0
        
        if distance_matrix[current_node, node] > np.max(distance_matrix) / 2:
            distance_weight = 2.0
        if uncertainty_scores[node] < np.max(uncertainty_scores) / 2:
            uncertainty_weight = 2.0
        if degree[node] < np.max(degree) / 2:
            degree_weight = 2.0
        if degree_ratio[node] < np.max(degree_ratio) / 2:
            degree_ratio_weight = 2.0
        if uncertainty_scores[node] > np.mean(uncertainty_scores):
            iterative_uncertainty_weight = 2.0
        if iterative_degree_ratio[node] > np.mean(iterative_degree_ratio):
            iterative_degree_ratio_weight = 2.0
        
        weighted_score = distance_weight * weighted_distances[node] + uncertainty_weight * uncertainty_scores[node] + degree_weight * degree[node] + degree_ratio_weight * degree_ratio[node] + iterative_uncertainty_weight * uncertainty_scores[node] + iterative_degree_ratio_weight * iterative_degree_ratio[node]
        weighted_scores[node] = weighted_score
    
    # Select the node with the highest weighted score as the next node to visit
    nxt_node = np.argmax(weighted_scores)
    
    return nxt_node
```
