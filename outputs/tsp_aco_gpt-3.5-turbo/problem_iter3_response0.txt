Code description: In this crossover algorithm, I will combine the ideas from Algorithm 1 and Algorithm 2 to create a better scoring function. The new scoring function will incorporate the concepts of hop count, average distance of connected nodes, sum of distances to other nodes, edge centrality, and normalized heuristic measures. By considering these factors, the scoring function aims to provide more accurate and effective heuristic measures for each edge. Additionally, I will calculate the inverse distances of each edge similar to Algorithm 2, and use the heuristic measures calculated in Algorithm 1 to prioritize edges that have a close destination node with fewer connections.

```python
import numpy as np

def scoring_function(distance_matrix: np.ndarray) -> np.ndarray:
    """
    The heuristic measures indicate how promising is each edge before actually solving this TSP instance.
    
    Parameters
    ----------
    distance_matrix : np.ndarray
        The distance matrix of shape (n_nodes, n_nodes), where diagonal elements are set to inf.
    
    Returns
    -------
    heuristics: np.ndarray
        The heuristic measures of shape (n_nodes, n_nodes) for all edges. 
    """
    n_nodes = distance_matrix.shape[0]
    
    # Compute the inverse of the distance matrix
    inverse_distance_matrix = np.where(distance_matrix != 0, 1 / distance_matrix, 0)
    
    # Compute the average distance of connected nodes for each node
    connected_nodes_avg_distance = np.sum(inverse_distance_matrix, axis=1) / (n_nodes - 1)
    
    # Compute the hop count between nodes
    hop_count = np.zeros((n_nodes, n_nodes), dtype=int)
    for hop in range(1, n_nodes):
        hop_count += (distance_matrix <= hop)
    
    # Compute the sum of distances to other nodes for each node
    node_scores = np.sum(inverse_distance_matrix, axis=1)
    
    # Multiply the inverse distances with heuristic measures from Algorithm 1
    heuristics = inverse_distance_matrix * connected_nodes_avg_distance[:, np.newaxis] * hop_count
    
    # Calculate edge centrality score
    centrality_score = np.sum(inverse_distance_matrix, axis=1) / np.sum(inverse_distance_matrix)
    
    # Multiply the centrality score with the heuristic measures
    heuristics *= centrality_score[:, np.newaxis]
    
    # Normalize the heuristic measures so that they sum up to 1
    heuristics /= np.sum(heuristics, axis=1, keepdims=True)
    
    return heuristics
```
