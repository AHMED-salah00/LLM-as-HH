Code description: The novel scoring function combines elements from Algorithm 1 and Algorithm 2. It considers the degree of nodes, hop count between nodes, centrality score, normalization, and the sum of distances to other nodes for each node. Additionally, the calculation of the hop count is optimized using the scipy library to compute the shortest path lengths between nodes.

```python
import numpy as np
from scipy.sparse import csr_matrix
from scipy.sparse.csgraph import floyd_warshall
import networkx as nx

def scoring_function(distance_matrix: np.ndarray) -> np.ndarray:
    """
    The heuristic measures indicate how promising is each edge before actually solving this TSP instance.
    
    Parameters
    ----------
    distance_matrix : np.ndarray
        The distance matrix of shape (n_nodes, n_nodes), where diagonal elements are set to inf.
    
    Returns
    -------
    heuristics: np.ndarray
        The heuristic measures of shape (n_nodes, n_nodes) for all edges. 
    """
    
    n_nodes = distance_matrix.shape[0]
    
    # Compute the inverse of the distance matrix
    inverse_distance_matrix = np.where(distance_matrix != 0, 1 / distance_matrix, 0)
    
    # Compute the degree of each node
    node_degrees = np.count_nonzero(distance_matrix, axis=1)
    
    # Compute the hop count between nodes
    hop_count = floyd_warshall(csr_matrix(distance_matrix, dtype=np.float64))
    
    # Compute the sum of distances to other nodes for each node
    node_scores = np.sum(inverse_distance_matrix, axis=1)

    # Compute the average distance of connected nodes for each node
    connected_nodes_avg_distance = np.sum(inverse_distance_matrix, axis=1) / (n_nodes - 1)
    
    # Compute the edge centrality measure
    edge_centrality = np.sum(inverse_distance_matrix, axis=1) / np.sum(inverse_distance_matrix)
    
    # Compute the heuristic measures
    heuristics = (inverse_distance_matrix * (1 / node_degrees[:, np.newaxis]) * hop_count * connected_nodes_avg_distance[:, np.newaxis]) / (node_scores[:, np.newaxis] ** 2)
    
    # Multiply the node degrees with the heuristic measures
    heuristics *= node_degrees[:, np.newaxis]
    
    # Multiply the edge centrality with the heuristic measures
    heuristics *= edge_centrality[:, np.newaxis]
    
    # Normalize the heuristic measures
    heuristics /= np.sum(inverse_distance_matrix)
    
    return heuristics
```

