Code description:
In this code, I will combine the ideas from Algorithm 1 and Algorithm 2 to create an enhanced scoring function. The scoring function will calculate a modified edge importance measure that takes into account both the degree centrality and the modified distance ratio. The degree centrality measure indicates how well-connected the destination node is to other nodes, and the modified distance ratio quantifies the difference between the current distance and the average distance. By combining these two measures, we can effectively evaluate the edges based on their centrality and relative position in the TSP instance.

```python
import numpy as np

def scoring_function(distance_matrix: np.ndarray) -> np.ndarray:
    """
    The heuristic measures indicate how promising is each edge before actually solving this TSP instance.
    
    Parameters
    ----------
    distance_matrix : np.ndarray
        The distance matrix of shape (n_nodes, n_nodes), where diagonal elements are set to inf.
    
    Returns
    -------
    heuristics: np.ndarray
        The heuristic measures of shape (n_nodes, n_nodes) for all edges. 
    """
    n_nodes = distance_matrix.shape[0]
    
    # Initialize the heuristic measures matrix
    heuristics = np.zeros((n_nodes, n_nodes))
    
    # Compute the inverse of the distance matrix
    inverse_distance_matrix = np.where(distance_matrix != 0, 1 / distance_matrix, 0)
    
    # Compute the degree centrality of each node
    degree_centrality = np.sum(inverse_distance_matrix, axis=1) / (n_nodes - 1)
    
    # Calculate the average distance in the distance matrix
    average_distance = np.mean(distance_matrix[distance_matrix != np.inf])
    
    # Calculate the heuristic measure for each edge
    for i in range(n_nodes):
        for j in range(n_nodes):
            if i != j:
                distance_ratio = abs(distance_matrix[i, j] - average_distance) / average_distance
                edge_importance = (degree_centrality[i] + degree_centrality[j]) / 2
                heuristics[i, j] = distance_ratio * edge_importance
    
    # Normalize the heuristic measures so that they sum up to 1
    heuristics /= np.sum(heuristics)
    
    return heuristics
```

