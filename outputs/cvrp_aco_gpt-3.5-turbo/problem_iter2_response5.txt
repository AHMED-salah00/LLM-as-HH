Code description: The crossover algorithm aims to combine the best features of Algorithm 1 and Algorithm 2 to create a more effective scoring function. This new scoring function will consider the distance, demand, and position of each node in order to assign heuristic measures to each edge. The weights assigned to distance, demand, and position can be customized to adjust the importance of each factor.

```python
import numpy as np

def scoring_function(distance_matrix: np.ndarray, demands: np.ndarray, CAPACITY: int) -> np.ndarray:
    n_nodes = distance_matrix.shape[0]

    max_distance = np.max(distance_matrix)
    max_demand = np.max(demands[1:])

    heuristics = np.zeros((n_nodes, n_nodes))

    # Weight parameters for distance, demand, and position
    distance_weight = 0.5
    demand_weight = 0.3
    position_weight = 0.2

    # Calculate the position factor for each node
    positions = (np.arange(n_nodes) + 1) / n_nodes

    for i in range(n_nodes):
        for j in range(n_nodes):
            if i != j:
                distance = distance_matrix[i, j]
                demand_ratio = demands[j] / CAPACITY

                normalized_distance = distance / max_distance
                normalized_demand_ratio = demand_ratio / max_demand
                normalized_position = positions[j]

                heuristics[i, j] = (distance_weight * normalized_distance) + (demand_weight * normalized_demand_ratio) + (position_weight * normalized_position)

    return heuristics
```
I have chosen to keep the weight parameters from Algorithm 2 as they are since they seem reasonable for this task.
