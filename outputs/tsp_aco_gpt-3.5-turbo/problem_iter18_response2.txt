Code description: The improved scoring function incorporates elements from both Algorithm 1 and Algorithm 2. It calculates the inverse distances of each edge and includes the degree centrality of the destination node. Additionally, it considers the edge importance measure and the closeness centrality of nodes. The edge importance measure combines the degree centrality and the distance between nodes, while the closeness centrality measures how close a node is to all other nodes. The heuristics are calculated by combining these measures and normalizing them to sum up to 1.

```python
import numpy as np
import networkx as nx
from scipy.sparse import csgraph

def scoring_function(distance_matrix: np.ndarray) -> np.ndarray:
    """
    The heuristic measures indicate how promising is each edge before actually solving this TSP instance.
    
    Parameters
    ----------
    distance_matrix : np.ndarray
        The distance matrix of shape (n_nodes, n_nodes), where diagonal elements are set to inf.
    
    Returns
    -------
    heuristics: np.ndarray
        The heuristic measures of shape (n_nodes, n_nodes) for all edges. 
    """
    n_nodes = distance_matrix.shape[0]
   
    # Compute the inverse of the distance matrix
    inverse_distances = 1 / distance_matrix
    np.fill_diagonal(inverse_distances, 0)
    
    # Compute the degree centrality of each node
    degree_centrality = np.sum(inverse_distances, axis=0) / (n_nodes - 1)
    
    # Compute the edge importance measure
    edge_importance = np.zeros((n_nodes, n_nodes))
    max_degree_centrality = np.max(degree_centrality)
    for i in range(n_nodes):
        for j in range(n_nodes):
            node_distance_score = 1 / (distance_matrix[i, j] + 1)
            edge_importance[i, j] = (degree_centrality[i] + degree_centrality[j]) / (2 * max_degree_centrality) * node_distance_score
    
    # Calculate the closeness centrality of each node
    closeness_centrality = csgraph.shortest_path(distance_matrix, directed=False)
    closeness_centrality = 1 / np.average(closeness_centrality, axis=1)
    
    # Calculate the heuristic measures
    heuristics = inverse_distances * degree_centrality[:, np.newaxis] * edge_importance * closeness_centrality[:, np.newaxis]
    
    # Normalize the heuristic measures so that they sum up to 1
    heuristics /= np.sum(heuristics)
    
    return heuristics
```
