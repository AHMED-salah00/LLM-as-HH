Code description: 
In this improved scoring function, I will combine the ideas from Algorithm 1 and Algorithm 2 to create a better scoring function. The scoring function will calculate the inverse distances of each edge similar to Algorithm 2. Then, I will modify the calculation of the heuristic measure for each edge to incorporate the degree of the destination node as well as the hop count between nodes. The final heuristic measures will be normalized to ensure they sum up to 1.

```python
import numpy as np
import networkx as nx

def scoring_function(distance_matrix: np.ndarray) -> np.ndarray:
    """
    The heuristic measures indicate how promising is each edge before actually solving this TSP instance.
    
    Parameters
    ----------
    distance_matrix : np.ndarray
        The distance matrix of shape (n_nodes, n_nodes), where diagonal elements are set to inf.
    
    Returns
    -------
    heuristics: np.ndarray
        The heuristic measures of shape (n_nodes, n_nodes) for all edges. 
    """
    n_nodes = distance_matrix.shape[0]
    
    # Compute the inverse of the distance matrix
    inverse_distance_matrix = np.where(distance_matrix != 0, 1 / distance_matrix, 0)
    
    # Compute the degree of each node
    node_degrees = np.count_nonzero(distance_matrix, axis=1)
    
    # Compute the hop count between nodes using networkx library
    graph = nx.from_numpy_matrix(distance_matrix, create_using=nx.Graph)
    hop_count = nx.floyd_warshall_numpy(graph)
    
    # Compute the sum of distances to other nodes for each node
    node_scores = np.sum(inverse_distance_matrix, axis=1)
    
    # Compute the heuristic measures
    heuristics = inverse_distance_matrix * (1 / (node_degrees[:, np.newaxis] * hop_count))
    
    # Normalize the heuristic measures so that they sum up to 1
    heuristics /= np.sum(heuristics)
    
    return heuristics
```
Note: nx.floyd_warshall_numpy() returns a matrix of shortest path lengths between all pairs of nodes in a graph.
