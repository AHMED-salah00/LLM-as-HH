Code description: In this improved scoring function, I will integrate elements from both Algorithm 1 and Algorithm 2 to create a better heuristic measure. The scoring function will calculate the inverse distances as in Algorithm 2, and also consider the edge importance and node connections from Algorithm 1. To calculate the heuristic measures, I will multiply the inverse distance with the inverse number of connections for the destination node. Additionally, I will multiply the result with the average of the source and destination node degrees to incorporate edge importance. This way, the scoring function will give higher heuristic measures to edges with shorter distances, lower node connections, and higher node degrees.

```python
import numpy as np

def scoring_function(distance_matrix: np.ndarray) -> np.ndarray:
    """
    The heuristic measures indicate how promising is each edge before actually solving this TSP instance.
    
    Parameters
    ----------
    distance_matrix : np.ndarray
        The distance matrix of shape (n_nodes, n_nodes), where diagonal elements are set to inf.
    
    Returns
    -------
    heuristics: np.ndarray
        The heuristic measures of shape (n_nodes, n_nodes) for all edges. 
    """
    n_nodes = distance_matrix.shape[0]
    
    # Initialize the heuristic measures matrix
    heuristics = np.zeros((n_nodes, n_nodes))
    
    # Calculate the inverse distances
    inverse_distances = 1 / distance_matrix
    np.fill_diagonal(inverse_distances, 0)
    
    # Compute the node connections
    node_connections = np.sum(distance_matrix != np.inf, axis=1)
    
    # Compute the node degrees
    node_degrees = np.sum(distance_matrix != np.inf, axis=1) - 1
    
    # Calculate the edge importance measure
    edge_importance = (node_degrees[:, np.newaxis] + node_degrees) / (2 * np.max(node_degrees))
    
    # Calculate the heuristic measure for each edge
    for i in range(n_nodes):
        for j in range(n_nodes):
            if i != j:
                heuristics[i, j] = inverse_distances[i, j] * (1 / (1 + node_connections[j])) * (node_degrees[i] + node_degrees[j]) / (2 * np.max(node_degrees))
    
    # Normalize the heuristic measures so that they sum up to 1
    heuristics /= np.sum(heuristics)
    
    return heuristics
```

The resulting scoring function combines the inverse distance information, edge importance, and node connections to provide heuristic measures that prioritize edges with shorter distances, lower node connections, and higher node degrees. This integration allows for a better estimation of the potential usefulness of each edge in constructing an optimal solution for the TSP instance.
