Code description: 
The proposed algorithm aims to select the next node based on a combination of uncertainty, distance, and the number of unvisited neighbors for each unvisited node. The uncertainty score is calculated as the coefficient of variation (CV) of the distances to other nodes from the current node, which represents the variability of distances. The distance score is the inverse of the distance from the current node to each unvisited node. The number of unvisited neighbors score is the number of unvisited neighbors for each unvisited node. These scores are combined using equal weights, and the node with the highest weighted score will be selected as the next node to visit.

```python
import numpy as np

def select_next_node(current_node: int, destination_node: int, unvisited_nodes: set, distance_matrix: np.ndarray) -> int:
    """
    Select the next node to visit from the unvisited nodes based on uncertainty, distance, and number of unvisited neighbors.
    
    Parameters
    ----------
    current_node : int
        The current node.
    destination_node : int
        The destination node to return to.
    unvisited_nodes : set
        The set of unvisited nodes.
    distance_matrix : np.ndarray
        The distance matrix of shape (n_nodes, n_nodes).
    
    Returns
    -------
    nxt_node : int
        The next node to visit.
    """
    distances = distance_matrix[current_node]
    uncertainty_scores = []
    weights = []
    num_unvisited_neighbors = np.zeros(len(distance_matrix))
    
    for node in unvisited_nodes:
        distance = distances[node]
        variability = np.std(distance_matrix[:, node])
        degree = np.sum(distance_matrix[node,:] > 0)
        
        uncertainty_score = variability / np.mean(distance_matrix[:, node])
        distance_score = 1 / distance
        num_unvisited_neighbors_score = num_unvisited_neighbors[node]
        
        weighted_score = uncertainty_score + distance_score + num_unvisited_neighbors_score
        uncertainty_scores.append(uncertainty_score)
        weights.append(weighted_score)
    
    max_weight = np.max(weights)
    top_weight_nodes = [node for node, weight in zip(unvisited_nodes, weights) if weight == max_weight]
    nxt_node = np.random.choice(top_weight_nodes)

    return nxt_node
```

