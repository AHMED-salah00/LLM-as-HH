Code description: This improved scoring function aims to enhance the original algorithm by incorporating new features and adjusting the weight coefficients to optimize the contribution of these features to the heuristics. In addition to the clustering factor and demand density, the new features include the distance between nodes and the demand ratio. The weight coefficients of each feature have been modified to achieve a better balance between them.

```python
import numpy as np
from sklearn.cluster import KMeans

def scoring_function(distance_matrix: np.ndarray, demands: np.ndarray, CAPACITY: int) -> np.ndarray:
    n_nodes = distance_matrix.shape[0]
    
    max_distance = np.max(distance_matrix)
    max_demand = np.max(demands[1:])
    
    heuristics = np.zeros((n_nodes, n_nodes))
    
    distance_weight = 0.4                        # Adjusted weight for distance
    demand_weight = 0.2                          # Unchanged weight for demand
    neighbor_demand_ratio_weight = 0.15          # Adjusted weight for neighbor demand ratio
    clustering_weight = 0.1                      # Unchanged weight for clustering factor
    demand_density_weight = 0.15                 # Adjusted weight for demand density
    new_feature_weight = 0.1                     # New weight for the distance and demand ratio feature
    
    # Calculate clustering factor
    kmeans = KMeans(n_clusters=3)
    cluster_labels = kmeans.fit_predict(distance_matrix[1:, 1:])
    
    cluster_distances = np.zeros((n_nodes, n_nodes))
    for i in range(1, n_nodes):
        for j in range(i + 1, n_nodes):
            if cluster_labels[i-1] == cluster_labels[j-1]:
                cluster_distances[i, j] = distance_matrix[i, j]
                cluster_distances[j, i] = distance_matrix[j, i]
            else:
                cluster_distances[i, j] = max_distance
                cluster_distances[j, i] = max_distance
    
    # Calculate demand density
    demand_density = np.zeros(n_nodes)
    for i in range(1, n_nodes):
        neighbor_demand_sum = demands[i]
        neighbor_count = 1
        
        for j in range(1, n_nodes):
            if j != i and distance_matrix[i, j] < max_distance:
                neighbor_demand_sum += demands[j]
                neighbor_count += 1
        
        demand_density[i] = neighbor_demand_sum / (max_distance * neighbor_count)
    
    # Calculate heuristic measures
    for i in range(1, n_nodes):
        nearest_neighbor_demand_ratio = np.inf
        
        for j in range(1, n_nodes):
            if j != i:
                demand_ratio = demands[j] / CAPACITY
                if demand_ratio < 1 and demand_ratio < nearest_neighbor_demand_ratio:
                    nearest_neighbor_demand_ratio = demand_ratio
        
        for j in range(i + 1, n_nodes):
            distance = distance_matrix[i, j]
            demand_ratio = demands[j] / CAPACITY
            cluster_distance = cluster_distances[i, j]
            demand_density_score = demand_density[j]
            
            if demand_ratio > 1 or nearest_neighbor_demand_ratio > 1:
                heuristics[i, j] = 0
            else:
                normalized_distance = distance / max_distance
                normalized_demand_ratio = demand_ratio / max_demand
                normalized_neighbor_demand_ratio = nearest_neighbor_demand_ratio / max_demand
                clustering_factor = np.exp(-cluster_distance / max_distance)
                normalized_demand_density = demand_density_score / np.max(demand_density[1:])
                
                heuristics[i, j] = (
                    distance_weight * normalized_distance +
                    demand_weight * normalized_demand_ratio +
                    neighbor_demand_ratio_weight * normalized_neighbor_demand_ratio +
                    clustering_weight * clustering_factor +
                    demand_density_weight * normalized_demand_density +
                    new_feature_weight * normalized_distance * normalized_demand_ratio
                )
            
            # Symmetrically set heuristics for the lower triangle of the matrix
            heuristics[j, i] = heuristics[i, j]
    
    return heuristics
```

In this improved version, the weight coefficients for distance, neighbor demand ratio, and demand density have been adjusted to optimize their contribution to the heuristics. Additionally, a new feature has been introduced, which is the combination of distance and demand ratio, with its own weight coefficient. The coefficients were modified to provide a better balance between the features and improve the overall performance of the scoring function.
