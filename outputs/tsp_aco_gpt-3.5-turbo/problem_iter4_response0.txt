Code description: 
In this improved scoring function, I will incorporate additional features to enhance the effectiveness of the heuristics. The modifications include:

1. Connectivity score: In addition to the node degrees, I will also consider the average distance between adjacent nodes. This will capture the overall connectivity of the network.

2. Local optimization: Nodes in close proximity tend to have shorter tour lengths. I will incorporate a measure that accounts for the improvement in tour length when repeatedly inserting a node into a partial solution.

3. Normalization: Similar to the previous algorithm, I will normalize the heuristics to ensure that they sum up to 1.

```python
import numpy as np
import networkx as nx

def scoring_function(distance_matrix: np.ndarray) -> np.ndarray:
    """
    The heuristic measures indicate how promising is each edge before actually solving this TSP instance.
    
    Parameters
    ----------
    distance_matrix : np.ndarray
        The distance matrix of shape (n_nodes, n_nodes), where diagonal elements are set to inf.
    
    Returns
    -------
    heuristics: np.ndarray
        The heuristic measures of shape (n_nodes, n_nodes) for all edges. 
    """
    
    n_nodes = distance_matrix.shape[0]
    
    # Compute the inverse of the distance matrix
    inverse_distance_matrix = np.where(distance_matrix != 0, 1 / distance_matrix, 0)
    
    # Compute the degree of each node
    node_degrees = np.count_nonzero(distance_matrix, axis=1)
    
    # Compute the average distance between adjacent nodes
    average_distance = np.zeros((n_nodes, n_nodes))
    
    # Construct the graph using distance matrix
    graph = nx.from_numpy_matrix(distance_matrix, create_using=nx.Graph)
    
    # Calculate the average distance between adjacent nodes
    for node in range(n_nodes):
        for neighbor in graph.neighbors(node):
            average_distance[node, neighbor] = np.mean(distance_matrix[node, list(graph.neighbors(neighbor))])
    
    # Compute the hop count between nodes
    hop_count = np.zeros((n_nodes, n_nodes), dtype=int)
    
    # Calculate shortest path lengths using networkx library
    path_lengths = dict(nx.all_pairs_shortest_path_length(graph))
    
    # Compute the hop count
    for i in range(n_nodes):
        for j in range(n_nodes):
            hop_count[i, j] = path_lengths[i][j]
    
    # Compute the improvement in tour length
    improvement = np.zeros((n_nodes, n_nodes))
    for node in range(n_nodes):
        for i in range(n_nodes):
            if i != node:
                for j in range(n_nodes):
                    if j != node and i != j:
                        improvement[i, j] = distance_matrix[i, node] + distance_matrix[node, j] - distance_matrix[i, j]
    
    # Compute the sum of distances to other nodes for each node
    node_scores = np.sum(inverse_distance_matrix, axis=1)
    
    # Compute the heuristic measures
    heuristics = (inverse_distance_matrix * (1 / node_degrees[:, np.newaxis]) * hop_count * average_distance * improvement) / np.sum(inverse_distance_matrix)
    
    return heuristics
```

Note: I have added comments to explain each step of the algorithm.
