Code description: This modified scoring function combines the advantages of both Algorithm 1 and Algorithm 2 to create a better heuristic for solving the optimization problem. The scoring function takes into account the distance between nodes, the demand of nodes, the remaining capacity of the vehicle, and the position of nodes relative to the depot. It assigns higher scores to edges with shorter distances, nodes with higher demands, edges with lower remaining capacity, and nodes closer to the depot.

```python
import numpy as np

def scoring_function(distance_matrix: np.ndarray, demands: np.ndarray, CAPACITY: int) -> np.ndarray:
    n_nodes = distance_matrix.shape[0]
    
    # Initialize heuristics matrix
    heuristics = np.zeros((n_nodes, n_nodes))
    
    # Set a very large number for diagonal elements of distance matrix
    np.fill_diagonal(distance_matrix, np.inf)

    # Calculate remaining capacity for each node
    remaining_capacity = CAPACITY - demands[1:]
    
    # Maximum values for normalization
    max_distance = np.max(distance_matrix)
    max_demand = np.max(demands[1:])
    
    # Weight parameters for distance, demand, remaining capacity, and position
    distance_weight = 0.4
    demand_weight = 0.4
    remaining_capacity_weight = 0.1
    position_weight = 0.1
    
    # Calculate the position factor for each node
    positions = (np.arange(n_nodes) + 1) / (n_nodes-1)
    
    # Calculate heuristic measures for each edge
    for i in range(n_nodes):
        for j in range(i+1, n_nodes):
            distance = distance_matrix[i, j]
            demand = demands[j]
            remaining_cap = remaining_capacity[i]
            position = positions[j]
            
            # Calculate normalized distance, demand, remaining capacity, and position
            normalized_distance = distance / max_distance
            normalized_demand = demand / max_demand
            normalized_remaining_cap = remaining_cap / CAPACITY
            
            # Calculate heuristic score as weighted sum
            score = distance_weight * (1 / normalized_distance) + demand_weight * normalized_demand + remaining_capacity_weight * normalized_remaining_cap + position_weight * (1 / position)
            
            # Apply penalty for infeasible solutions
            if demand > CAPACITY or demand > remaining_cap:
                score = 0
            
            # Update heuristics matrix
            heuristics[i, j] = score
    
    # Symmetrically set heuristics for the lower triangle of the matrix
    heuristics += np.tril(heuristics.T, -1)
    
    return heuristics
```

