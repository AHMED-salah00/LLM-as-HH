Code description: In this improved scoring function, I will combine the best aspects of Algorithm 1 and Algorithm 2. I will consider the distance, demand, clustering, and demand density factors to calculate the heuristic measures. I will adjust the weight coefficients of these factors to optimize their contribution to the heuristics.

```python
import numpy as np
from sklearn.cluster import KMeans

def scoring_function(distance_matrix: np.ndarray, demands: np.ndarray, CAPACITY: int) -> np.ndarray:
    n_nodes = distance_matrix.shape[0]
    
    max_distance = np.max(distance_matrix)
    max_demand = np.max(demands[1:])
    
    heuristics = np.zeros((n_nodes, n_nodes))
    
    distance_weight = 0.5
    demand_weight = 0.2
    clustering_weight = 0.1
    demand_density_weight = 0.2
    
    # Calculate clustering factor
    kmeans = KMeans(n_clusters=3)
    cluster_labels = kmeans.fit_predict(distance_matrix[1:, 1:])
    
    cluster_distances = np.zeros((n_nodes, n_nodes))
    for i in range(1, n_nodes):
        for j in range(i + 1, n_nodes):
            if cluster_labels[i-1] == cluster_labels[j-1]:
                cluster_distances[i, j] = distance_matrix[i, j]
                cluster_distances[j, i] = distance_matrix[j, i]
            else:
                cluster_distances[i, j] = max_distance
                cluster_distances[j, i] = max_distance
    
    # Calculate demand density
    demand_density = np.zeros(n_nodes)
    for i in range(1, n_nodes):
        neighbor_demand_sum = demands[i]
        neighbor_count = 1
        
        for j in range(1, n_nodes):
            if j != i and distance_matrix[i, j] < max_distance:
                neighbor_demand_sum += demands[j]
                neighbor_count += 1
        
        demand_density[i] = neighbor_demand_sum / (max_distance * neighbor_count)
    
    # Calculate heuristic measures
    for i in range(1, n_nodes):
        for j in range(i + 1, n_nodes):
            distance = distance_matrix[i, j]
            demand_ratio = demands[j] / CAPACITY
            cluster_distance = cluster_distances[i, j]
            demand_density_score = demand_density[j]
            
            if demand_ratio > 1:
                heuristics[i, j] = 0
            else:
                normalized_distance = distance / max_distance
                normalized_demand_ratio = demand_ratio / max_demand
                clustering_factor = np.exp(-cluster_distance / max_distance)
                normalized_demand_density = demand_density_score / np.max(demand_density[1:])
                
                heuristics[i, j] = (
                    distance_weight * normalized_distance +
                    demand_weight * normalized_demand_ratio +
                    clustering_weight * clustering_factor +
                    demand_density_weight * normalized_demand_density
                )
            
            # Symmetrically set heuristics for the lower triangle of the matrix
            heuristics[j, i] = heuristics[i, j]
    
    return heuristics
```

