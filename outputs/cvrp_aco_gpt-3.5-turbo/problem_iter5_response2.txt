Code description: In this improved scoring function, I will combine the best features of the two algorithms while optimizing the weight coefficients. The scoring function will consider the distance, demand, position of each node, and the remaining capacity. I will normalize the distance and demand using the maximum values in the respective arrays. The weight coefficients for distance, demand, position, and capacity will be adjustable parameters.

```python
import numpy as np

def scoring_function(distance_matrix: np.ndarray, demands: np.ndarray, CAPACITY: int) -> np.ndarray:
    n_nodes = distance_matrix.shape[0]

    max_distance = np.max(distance_matrix)
    max_demand = np.max(demands[1:])
    
    heuristics = np.zeros((n_nodes, n_nodes))
    
    # Set weight coefficients for distance, demand, position, and capacity (optimized values)
    distance_weight = 0.5
    demand_weight = 0.4
    position_weight = 0.1
    capacity_weight = 0.1

    for i in range(1, n_nodes):
        for j in range(i + 1, n_nodes):
            distance = distance_matrix[i, j]
            demand_ratio = demands[j] / CAPACITY
            remaining_capacity = CAPACITY - demands[j]

            if demand_ratio > 1:
                heuristics[i, j] = -max_distance
            else:
                normalized_distance = distance / max_distance
                normalized_demand_ratio = demand_ratio / max_demand
                normalized_position = (j - 1) / (n_nodes - 1)

                heuristics[i, j] = distance_weight * normalized_distance + demand_weight * normalized_demand_ratio + position_weight * normalized_position + capacity_weight * remaining_capacity
            
            # Symmetrically set heuristics for the lower triangle of the matrix
            heuristics[j, i] = heuristics[i, j]

    return heuristics
```

