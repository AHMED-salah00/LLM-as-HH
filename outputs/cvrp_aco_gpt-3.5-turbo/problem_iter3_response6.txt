Code description: The crossover algorithm combines the strengths of both Algorithm 1 and Algorithm 2, while introducing additional improvements. It considers distance, demand, position, and capacity constraints to prioritize edges. The idea is to assign higher heuristic measures to edges that are closer to the depot, have a higher demand, and are within the vehicle capacity. Infeasible solutions are penalized by assigning lower heuristic measures to edges that exceed the vehicle capacity. The crossover implementation improves efficiency by avoiding unnecessary calculations and precomputing normalization factors. The final heuristic measure is calculated as a weighted sum of distance, demand, position, and penalty factors.

```python
import numpy as np

def scoring_function(distance_matrix: np.ndarray, demands: np.ndarray, CAPACITY: int) -> np.ndarray:
    n_nodes = distance_matrix.shape[0]
    
    # Initialize heuristics matrix
    heuristics = np.zeros((n_nodes, n_nodes))
    
    # Maximum values for normalization
    max_distance = np.max(distance_matrix)
    max_demand = np.max(demands[1:])
    
    # Weight parameters for distance, demand, position, and infeasibility penalty
    distance_weight = 0.5
    demand_weight = 0.35
    position_weight = 0.1
    penalty_weight = 0.05
    
    # Calculate normalized demands and positions
    normalized_demands = demands[1:] / max_demand
    positions = np.arange(1, n_nodes) / n_nodes
    
    for i in range(n_nodes):
        for j in range(i+1, n_nodes):
            distance = distance_matrix[i, j]
            
            # Calculate normalized distance
            normalized_distance = distance / max_distance
            
            # Check capacity constraint
            if demands[j] > CAPACITY:
                heuristics[i, j] = 0
            else:
                # Calculate heuristics measure
                heuristics[i, j] = (
                    distance_weight * normalized_distance +
                    demand_weight * normalized_demands[j-1] +
                    position_weight * positions[j-1]
                )

    # Symmetrically set heuristics for the lower triangle of the matrix
    heuristics += np.tril(heuristics.T, -1)
    
    return heuristics
```

