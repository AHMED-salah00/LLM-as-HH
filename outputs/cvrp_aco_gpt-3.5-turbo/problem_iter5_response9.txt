Code description: 

The crossover algorithm combines the best features of Algorithm 1 and Algorithm 2 to create a more effective scoring function. It considers the distance, demand, position, and degree centrality of each node to assign heuristic measures to each edge. The weights assigned to each factor can be customized to adjust their importance. Additionally, the algorithm penalizes edges that exceed the vehicle capacity.

The crossover algorithm calculates the degree centrality of each node and creates an empty array for the heuristic measures. It then iterates over all pairs of nodes (i, j) and calculates the heuristic measure for the edge connecting these nodes. For each edge, the heuristic measure is calculated as follows:

- If the edge connects the depot (node 0) to a customer node (i > 0), the heuristic measure is set to a weighted sum of the normalized demand of the customer node, the ratio of the normalized demand to the distance, the position of the customer node, and the degree centrality of the customer node. The weights control the importance of each factor.

- If the edge connects two customer nodes (i > 0 and j > 0), the heuristic measure is set to a weighted sum of the normalized sum of the demands of the two nodes, the ratio of the normalized sum of the demands to the distance, the position of the second customer node, and the degree centrality of the second customer node. The weights control the importance of each factor.

Additionally, the crossover algorithm introduces a capacity penalty factor for edges that exceed the vehicle capacity. If the demand sum of the two nodes exceeds the vehicle capacity, the heuristic measure is multiplied by a penalty factor to reduce its importance.

The resulting heuristic measures are returned as an array.


```python
import numpy as np
import networkx as nx

def scoring_function(distance_matrix: np.ndarray, demands: np.ndarray, CAPACITY: int) -> np.ndarray:
    n_nodes = distance_matrix.shape[0]

    max_distance = np.max(distance_matrix)
    max_demand = np.max(demands[1:])

    heuristics = np.zeros((n_nodes, n_nodes))

    distance_weight = 0.45  # Weight for the distance factor
    demand_weight = 0.25  # Weight for the demand factor
    centrality_weight = 0.3  # Weight for the centrality factor

    # Calculate degree centrality of each node
    G = nx.from_numpy_array(distance_matrix)
    centrality = nx.degree_centrality(G)

    for i in range(n_nodes):
        for j in range(n_nodes):
            if i != j:
                demand_sum = demands[i] + demands[j]
                distance = distance_matrix[i, j]
                
                if i == 0:
                    normalized_demand = demands[j] / max_demand
                    position = (j - 1) / (n_nodes - 1)
                    
                    heuristic_demand = normalized_demand ** demand_weight
                    heuristic_distance = distance_weight / distance
                    heuristic_position = (1 - demand_weight - distance_weight) * position
                    heuristic_centrality = centrality[j] ** centrality_weight
                    
                    heuristics[i, j] = (heuristic_demand + heuristic_distance + heuristic_position + heuristic_centrality)
                elif j == 0:
                    normalized_demand = demands[i] / max_demand
                    position = (i - 1) / (n_nodes - 1)
                    
                    heuristic_demand = normalized_demand ** demand_weight
                    heuristic_distance = distance_weight / distance
                    heuristic_position = (1 - demand_weight - distance_weight) * position
                    heuristic_centrality = centrality[i] ** centrality_weight
                    
                    heuristics[i, j] = (heuristic_demand + heuristic_distance + heuristic_position + heuristic_centrality)
                else:
                    normalized_demand_sum = demand_sum / max_demand
                    position = (j - 1) / (n_nodes - 1)
                    
                    heuristic_demand = normalized_demand_sum ** demand_weight
                    heuristic_distance = distance_weight / distance
                    heuristic_position = (1 - demand_weight - distance_weight) * position
                    heuristic_centrality = centrality[j] ** centrality_weight
                    
                    if demand_sum > CAPACITY:
                        capacity_penalty = CAPACITY / demand_sum
                        heuristic_capacity_penalty = 1 - centrality_weight * capacity_penalty
                        heuristics[i, j] = (heuristic_demand + heuristic_distance + heuristic_position) * heuristic_capacity_penalty
                    else:
                        heuristics[i, j] = (heuristic_demand + heuristic_distance + heuristic_position + heuristic_centrality)
                    
    return heuristics
```

