Code description: The proposed algorithm combines elements from both Algorithm 1 and Algorithm 2 to create a novel selecting-next-node function. It takes into account the distance between the current node and each unvisited node, as well as the average distance of unvisited nodes to their neighboring unvisited nodes. This approach aims to balance between minimizing edge length and exploring neighbors of unvisited nodes.

```python
import numpy as np

def select_next_node(current_node: int, destination_node: int, unvisited_nodes: set, distance_matrix: np.ndarray) -> int:
    # Calculate distance from current node to each unvisited node
    current_distances = distance_matrix[current_node, list(unvisited_nodes)]
    
    # Calculate Neighbor Distance for each unvisited node
    neighbor_distance = {}
    for node in unvisited_nodes:
        neighbor_distances = distance_matrix[node, list(unvisited_nodes - set([node]))]
        neighbor_distance[node] = np.mean(neighbor_distances)
        
    # Calculate combined scores for each unvisited node
    combined_scores = 0.7 * current_distances + 0.3 * np.array(list(neighbor_distance.values()))
    
    # Find the node with the highest combined score
    nxt_node = list(unvisited_nodes)[np.argmin(combined_scores)]
    
    return nxt_node
```

Note: In this algorithm, I removed the calculation of destination distances and Modified Greedy Squeezing distance from Algorithm 1 as they did not significantly contribute to the solution quality. I increased the weight of current distances to give more importance to minimizing edge length. The combined score is calculated as a weighted sum of current distances and neighbor distances, with a higher weight given to current distances. The next node to visit is selected as the node with the minimum combined score, indicating the node with the shortest edge length and proximity to neighboring unvisited nodes.
