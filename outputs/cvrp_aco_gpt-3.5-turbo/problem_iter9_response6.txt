Code description: 
The improved scoring function aims to combine the strengths of both Algorithm 1 and Algorithm 2. It considers features such as distance, demand, clustering, demand density, local search, spatial proximity, and capacity constraints. The weight coefficients of each feature will be adjusted to achieve a better balance between them and enhance the importance of local search and capacity penalty.

```python
import numpy as np
from sklearn.cluster import KMeans
import networkx as nx

def scoring_function(distance_matrix: np.ndarray, demands: np.ndarray, CAPACITY: int) -> np.ndarray:
    n_nodes = distance_matrix.shape[0]
    
    max_distance = np.max(distance_matrix)
    max_demand = np.max(demands[1:])
    
    heuristics = np.zeros((n_nodes, n_nodes))
    
    distance_weight = 0.5 
    demand_weight = 0.2  
    clustering_weight = 0.1  
    demand_density_weight = 0.05  
    local_search_weight = 0.2  
    proximity_weight = 0.15  
    capacity_penalty_weight = 0.1  
    
    G = nx.from_numpy_array(distance_matrix)
    degree_centrality = nx.degree_centrality(G)
    
    kmeans = KMeans(n_clusters=3)
    cluster_labels = kmeans.fit_predict(distance_matrix[1:, 1:])
    
    cluster_distances = np.zeros((n_nodes, n_nodes))
    for i in range(1, n_nodes):
        for j in range(i + 1, n_nodes):
            if cluster_labels[i-1] == cluster_labels[j-1]:
                cluster_distances[i, j] = distance_matrix[i, j]
                cluster_distances[j, i]= distance_matrix[j, i]
            else:
                cluster_distances[i, j] = max_distance
                cluster_distances[j, i] = max_distance
    
    # Calculate demand density
    demand_density = np.zeros(n_nodes)
    for i in range(1, n_nodes):
        neighbor_demand_sum = demands[i]
        neighbor_count = 1
        
        for j in range(1, n_nodes):
            if j != i and distance_matrix[i, j] < max_distance:
                neighbor_demand_sum += demands[j]
                neighbor_count += 1
        
        demand_density[i] = neighbor_demand_sum / (max_distance * neighbor_count)
    
    for i in range(1, n_nodes):
        for j in range(i + 1, n_nodes):
            distance = distance_matrix[i, j]
            demand_ratio = demands[j] / CAPACITY
            
            normalized_distance = distance / max_distance
            normalized_demand_ratio = demand_ratio
            normalized_demand_density = demand_density[j]
            normalized_demand_i = demands[i] / max_demand
            normalized_demand_j = demands[j] / max_demand
            position = j / (n_nodes - 1)
            remaining_capacity = CAPACITY - demands[j]
            
            if demand_ratio > 1:
                heuristics[i, j] = -1e9
                heuristics[j, i] = -1e9
            else:
                clustering_factor = np.exp(-cluster_distances[i, j] / max_distance)
                local_search_factor = (1 - normalized_distance) / (degree_centrality[i] + degree_centrality[j])
                proximity_factor = (1 - normalized_demand_ratio) / (degree_centrality[i] + degree_centrality[j])
                demand_density_factor = demand_density_weight * normalized_demand_density
                demand_factor = demand_weight * (normalized_demand_i + normalized_demand_j) / (normalized_demand_i + normalized_demand_j + proximity_factor)
                position_factor = position * demand_density_factor
                capacity_penalty_factor = capacity_penalty_weight * max(0, remaining_capacity / CAPACITY)
                
                heuristics[i, j] = (
                    distance_weight * local_search_factor +
                    demand_factor +
                    clustering_weight * clustering_factor +
                    demand_density_factor +
                    local_search_weight * (position_factor + proximity_factor) +
                    proximity_weight * proximity_factor -
                    capacity_penalty_factor
                )
                
                heuristics[j, i] = heuristics[i, j]
    
    return heuristics
```

