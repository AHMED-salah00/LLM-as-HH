Code description: I propose a novel scoring function that combines the hop count measure from Algorithm 1 with a modified version of the centrality score measure from Algorithm 2. Instead of using the sum of distances to other nodes as the centrality score, I will use the average distance of connected nodes as the centrality score. This modification allows the scoring function to capture both the local connectivity and global importance of nodes effectively.

```python
import numpy as np

def scoring_function(distance_matrix: np.ndarray) -> np.ndarray:
    """
    The heuristic measures indicate how promising is each edge before actually solving this TSP instance.
    
    Parameters
    ----------
    distance_matrix : np.ndarray
        The distance matrix of shape (n_nodes, n_nodes), where diagonal elements are set to inf.
    
    Returns
    -------
    heuristics: np.ndarray
        The heuristic measures of shape (n_nodes, n_nodes) for all edges. 
    """
    n_nodes = distance_matrix.shape[0]
    
    # Compute the inverse of the distance matrix
    inverse_distance_matrix = np.where(distance_matrix != 0, 1 / distance_matrix, 0)
    
    # Compute the average distance of connected nodes for each node
    connected_nodes_avg_distance = np.sum(inverse_distance_matrix, axis=1) / (n_nodes - 1)
    
    # Compute the hop count between nodes
    hop_count = np.zeros((n_nodes, n_nodes), dtype=int)
    for hop in range(1, n_nodes):
        hop_count += (distance_matrix <= hop)
    
    # Compute the sum of distances to other nodes for each node
    node_scores = np.sum(inverse_distance_matrix, axis=1)
    
    # Repeat the node scores for each edge
    edge_scores = np.repeat(node_scores[:, np.newaxis], n_nodes, axis=1)
    
    # Compute the heuristic measures for each edge
    heuristics = (inverse_distance_matrix * connected_nodes_avg_distance[:, np.newaxis] * hop_count) / edge_scores
    
    # Calculate centrality score based on average distance of connected nodes
    centrality_score = connected_nodes_avg_distance / np.sum(connected_nodes_avg_distance)
    
    # Multiply the centrality score with heuristic measures
    heuristics *= centrality_score[:, np.newaxis]
    
    return heuristics
```

In this modified scoring function, I first compute the inverse of the distance matrix to avoid division by zero errors. Then, I calculate the average distance of connected nodes for each node and the hop count between nodes. Next, I compute the sum of distances to other nodes for each node and repeat these scores for each edge. Finally, I calculate the centrality score based on the average distance of connected nodes and multiply it with the heuristic measures to obtain the final scores.
